# 基本类型

Rust每个值都有确切的类型，可以分为两类：基本类型（Primitive Type）和复合类型（Compound Type）。

基本类型意味着它们是一个最小化原子类型，无法解构为其他类型，由以下组成：

* 数值类型：有符号整数（i8, i16, i32, i64, i128, isize）、无符号整数（u8, u16, u32, u64, u128, usize）、浮点数（f32, f64）、以及有理数、复数
* 字符串： 字符串字面量 `&'static str` 和字符串切片`&str`
* 布尔类型： `true`和`false`
* 字符类型： 表示单个Unicode字符，存储为4个字节（一个u32类型整数表示）
* 单元类型：即`()`，其唯一的值也是`()`



# 类型推导与标注

大部分时候，我们不需要为变量指定类型，Rust编译器很聪明，它可以根据变量的值和上下文的使用方式来自动推导出变量的类型。 

但自动类型推导也不是万能的，在某些情况下，其也无法推导出变量类型，此时就需要手动添加类型标注。如下面代码：

```rust
let guess = "42".parse().expect("Not a number!");
```

此时编译器就会报错，因为其无法推导出我们想要的类型是：整数？浮点数？字符串？

需要改为：

```rust
let guess: i32 = ... 或者 "42".parse::<i32>()
```



# 数值类型

## 整数和浮点数

整数和浮点数的运算是通过运算符来完成。不仅仅整数，Rust也允许在复杂类型上定义运算符，例如在自定义类型上定义`+`运算符，这种行为被称为运算符重载。



### 整数类型

| 长度       | 有符号类型 | 无符号类型 |
| ---------- | ---------- | ---------- |
| 8 位       | `i8`       | `u8`       |
| 16 位      | `i16`      | `u16`      |
| 32 位      | `i32`      | `u32`      |
| 64 位      | `i64`      | `u64`      |
| 128-位     | `i128`     | `u128`     |
| 视架构而定 | `isize`    | `usize`    |



**整形字面量可以用下表的形式书写：**

| 数字字面量         | 示例          |
| ------------------ | ------------- |
| 十进制             | `98_222`      |
| 十六进制           | `0xff`        |
| 八进制             | `0o77`        |
| 二进制             | `0b1111_0000` |
| 字节 (仅限于 `u8`) | `b'A'`        |

Rust的整形默认使用`i32`，例如`let i = 1	`，那么`i`就是`i32`类型，同时该类型也往往是性能最好的。`isize`和`usize`的主要应用场景是用作集合的索引。



> **整形溢出**
>
> 要显式处理可能的溢出，可以使用标准库针对原始数字类型提供的这些方法：
>
> - 使用 `wrapping_*` 方法在所有模式下都按照补码循环溢出规则处理，例如 `wrapping_add`
> - 如果使用 `checked_*` 方法时发生溢出，则返回 `None` 值
> - 使用 `overflowing_*` 方法返回该值和一个指示是否存在溢出的布尔值
> - 使用 `saturating_*` 方法使值达到最小值或最大值
>
> 例如：
>
> ```rust
> let a: i32 = 128;
> let b = a.wrapping_add(100);
> ```



### 浮点类型

Rust中浮点类型包含两种类型：f32和f64。默认浮点类型是f64，在现代CPU中它速度和f32几乎相同，但精度更高。

示例：

```rust
fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
```

浮点数根据 `IEEE-754` 标准实现。`f32` 类型是单精度浮点型，`f64` 为双精度。



### 浮点数陷阱

* 浮点数往往是你想要数字的近似表达。 例如 `0.1` 在二进制上并不存在精确的表达形式，但是在十进制上就存在。
* 浮点数在某些特性上是反直觉的。`f32` ， `f64` 上的比较运算实现的是 `std::cmp::PartialEq` 特征(类似其他语言的接口)，但是并没有实现 `std::cmp::Eq` 特征。这就造成浮点数无法作为HashMap的K，因为HashMap要求其K必须实现`std::cmp::Eq`。
* 为了避免上面两个陷阱，需要遵守以下准则：
  - 避免在浮点数上测试相等性
  - 当结果在数学上可能存在未定义时，需要格外小心

那如果非要进行比较呢？可以考虑用这种方式 `(0.1 + 0.2 - 0.3).abs() < 0.00001` ，具体小于多少，取决于你对精度的需求。

下面看一段震撼灵魂的代码：

```rust
fn main() {
    let abc: (f32, f32, f32) = (0.1, 0.2, 0.3);
    let xyz: (f64, f64, f64) = (0.1, 0.2, 0.3);

    println!("abc (f32)");
    println!("   0.1 + 0.2: {:x}", (abc.0 + abc.1).to_bits());
    println!("         0.3: {:x}", (abc.2).to_bits());
    println!();

    println!("xyz (f64)");
    println!("   0.1 + 0.2: {:x}", (xyz.0 + xyz.1).to_bits());
    println!("         0.3: {:x}", (xyz.2).to_bits());
    println!();

    assert!(abc.0 + abc.1 == abc.2);
    assert!(xyz.0 + xyz.1 == xyz.2);
}
```

运行该程序，输出如下:

```tex
abc (f32)
   0.1 + 0.2: 3e99999a
         0.3: 3e99999a
 
xyz (f64)
   0.1 + 0.2: 3fd3333333333334
         0.3: 3fd3333333333333
 
thread 'main' panicked at 'assertion failed: xyz.0 + xyz.1 == xyz.2',
➥ch2-add-floats.rs.rs:14:5
note: run with `RUST_BACKTRACE=1` environment variable to display
➥a backtrace
```

仔细看，对 `f32` 类型做加法时，`0.1 + 0.2` 的结果是 `3e99999a`，`0.3` 也是 `3e99999a`，因此 `f32` 下的 `0.1 + 0.2 == 0.3` 通过测试，但是到了 `f64` 类型时，结果就不一样了，因为 `f64` 精度高很多，因此在小数点非常后面发生了一点微小的变化，`0.1 + 0.2` 以 `4` 结尾，但是 `0.3` 以`3`结尾，这个细微区别导致 `f64` 下的测试失败了，并且抛出了异常。



### NaN

对于数学上未定义的结果，例如对负数取平方根 `-42.1.sqrt()` ，会产生一个特殊的结果：Rust 的浮点数类型使用 `NaN` (not a number)来处理这些情况。

**所有跟 `NaN` 交互的操作，都会返回一个 `NaN`**，而且 `NaN` 不能用来比较，下面的代码会崩溃：

```rust
fn main() {
  let x = (-42.0_f32).sqrt();
  assert_eq!(x, x);
}
```

出于防御性编程的考虑，可以使用 `is_nan()` 等方法，可以用来判断一个数值是否是 `NaN` ：

```rust
fn main() {
    let x = (-42.0_f32).sqrt();
    if x.is_nan() {
        println!("未定义的数学行为")
    }
}
```



### 序列（Range）

Rust提供了一种非常简洁的方式，来生成连续的数值，例如`1..5`，生成从1到4的连续数字，不包含5；`1..=5`，生成从1到5的连续数字，包含5，此用途很简单，常常用在循环中：

```rust
for i in 1..=5 {
    println!("{}",i);
}
```

最终程序输出:

```tex
1
2
3
4
5
```



序列只允许用于数字或字符类型，如下是一个使用字符类型序列的例子：

```rust
for i in 'a'..='z' {
    println!("{}", i);
}
```



### 有理数和复数

Rust 的标准库相比其它语言，对于准入的门槛较高，因此有理数和复数并未包含在标准库中：

- 有理数和复数
- 任意大小的整数和任意精度的浮点数
- 固定精度的十进制小数，常用于货币相关的场景

好在社区已经开发出高质量的 Rust 数值库：[num](https://crates.io/crates/num)。

基于num库，使用复数的示例：

```rust
use num::complex::Complex;

fn main() {
    let a = Complex { re: 2.1, im: -1.2 };
    let b = Complex::new(11.1, 22.2);
    let result = a + b;

    println!("{} + {}i", result.re, result.im)
}

```



## 总结

* Rust有相当多的数值类型。
* 类型转换必须是显示的。Rust永远不会偷偷的把你的16bit整数转换为32bit整数。
* Rust数值上可以使用方法。例如你可以使用下面方法来将13.14取整：`13.14_f32.round()`，在这里我们使用了类型后缀，因为编译器需要知道 `13.14 `的具体类型









