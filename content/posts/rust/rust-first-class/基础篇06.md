---
title: "[Rust编程第一课]-07 基础篇06-数据结构：智能指针"
date: 2023-04-12T11:20:00+08:00
lastmod: 2023-04-12T19:30:00+08:00
author: nange
draft: false
description: "Rust编程第一课 基础部分"

categories: ["programming"]
series: ["rust-first-class"]
series_weight: 7
tags: ["rust"]
---

## 智能指针

* 指针回顾：指针是一个持有内存地址的值，可以通过解引用来访问它指向的内存地址，理论上可以解引用到任意数据类型；引用是一个特殊的指针，它的解引用访问是受限的，只能解引用到它引用数据的类型，不能用作它用。

* 智能指针是一个表现行为很像指针的数据结构，但除了指向数据的指针外，它还有元数据以提供额外的处理能力。

* 智能指针和胖指针的区别联系：

  * 智能指针一定是一个胖指针，但胖指针不一定是一个智能指针。比如 `&str` 就只是一个胖指针。

  * 能指针 `String` 和 `&str` 的区别：

    ![img](/images/f4401040f7d36b9e610b6867a5d0cf59.jpg)

    从图上可以看到，`String` 除了多一个 `capacity` 字段，似乎也没有什么特殊。但 `String` 对堆上的值有所有权，而 `&str` 是没有所有权的，这是 Rust 中智能指针和普通胖指针的区别。

* 另一个问题：智能指针和结构体有什么区别呢？`String` 是用结构体定义的：

  ```rust
  pub struct String {
      vec: Vec<u8>,
  }
  ```

  和普通的结构体不同的是，`String` 实现了 `Deref` 和 `DerefMut`，这使得它在解引用的时候，会得到 `&str`。标准库实现如下：

  ```rust
  impl ops::Deref for String {
      type Target = str;
  
      fn deref(&self) -> &str {
          unsafe { str::from_utf8_unchecked(&self.vec) }
      }
  }
  
  impl ops::DerefMut for String {
      fn deref_mut(&mut self) -> &mut str {
          unsafe { str::from_utf8_unchecked_mut(&mut *self.vec) }
      }
  }
  ```

  另外，由于在堆上分配了数据，String 还需要为其分配的资源做相应的回收。

  所以，**在 Rust 中，凡是需要做资源回收的数据结构，且实现了 Deref/DerefMut/Drop，都是智能指针。**

* 很多常见的数据结构都是智能指针，如：`String`, `Box<T>`, `Vec<T>`, `Rc<T>`, `Arc<T>`, `PathBuf`, `Cow<'a, B>` , `MutexGuard<T>`, `RwLockReadGuard<T>`, `RwLockWriteGuard<T>`等。
* 下面重点分析三个：`Box<T>`用于堆上分配内存，`Cow<'a, B>`提供写时克隆，`MutexGuard<T>`用于数据加锁

## Box<T>

* 它是 Rust 中最基本的在堆上分配内存的方式，绝大多数其它包含堆内存分配的数据类型，内部都是通过 `Box<T>` 完成的，比如 `Vec<T>`。

* `Box` 有一个缺省的泛型参数 `A`，需要满足 `Allocator` trait，并且默认是 `Global`：

  ```rust
  pub struct Box<T: ?Sized,A: Allocator = Global>(Unique<T>, A)
  ```

  * `Allocator` trait 提供很多方法：

    * `allocate` 是主要方法，用于分配内存，对应 C 的 `malloc/calloc`；

    * `deallocate`，用于释放内存，对应 C 的 `free`；

    * 还有 `grow / shrink`，用来扩大或缩小堆上已分配的内存，对应 C 的 `realloc`。

  * 如果想替换默认的内存分配器，可以使用 `#[global_allocator]` 标记宏，定义自己的全局分配器。下面的代码展示了如何在 Rust 下使用 `jemalloc`：

    ```rust
    use jemallocator::Jemalloc;
    
    #[global_allocator]
    static GLOBAL: Jemalloc = Jemalloc;
    
    fn main() {}
    ```

    这样设置之后，使用 `Box::new()` 分配的内存就是 `jemalloc` 分配出来的了。

### 使用场景

* 示例：

  ```rust
  struct Matrix {
      data: [u8; 505],
  }
  
  impl Default for Matrix {
      fn default() -> Self {
          Self { data: [0; 505] }
      }
  }
  
  fn main() {
      let data = Box::new(Matrix::default());
  
      println!(
          "!!! allocated memory: {:p}, len: {}",
          &*data,
          std::mem::size_of::<Matrix>()
      );
  }
  ```

* 在使用 `Box` 分配堆内存的时候要注意，`Box::new()` 是一个函数，所以传入它的数据会出现在栈上，再移动到堆上。如果是一个非常大的结构，就有可能出问题。比如下面的代码：

  ```rust
  fn main() {
      // 在堆上分配 16M 内存，但它会现在栈上出现，再移动到堆上
      let boxed = Box::new([0u8; 1 << 24]);
      println!("len: {}", boxed.len());
  }
  ```

  * 但如果你在本地使用 `cargo run —release` 编译成 release 代码运行，会正常执行！

  * 这是因为默认的debug模式，不会做任何的inline优化

  * 在 release 模式下，这个函数调用会被优化掉：

    ```rust
    #[inline(always)]
    pub fn new(x: T) -> Self {
        box x
    }
    ```

    关键字 `box` 是 Rust 内部的关键字，用户代码无法调用，用于分配堆内存，`box` 关键字在编译时，会使用内存分配器分配内存。

* `Box<T>`内存释放，来看它实现的 `Drop` trait：

  ```rust
  unsafe impl<#[may_dangle] T: ?Sized, A: Allocator> Drop for Box<T, A> {
      fn drop(&mut self) {
          // FIXME: Do nothing, drop is currently performed by compiler.
      }
  }
  ```

  目前 `drop` trait 什么都没有做，编译器会自动插入 deallocate 的代码。这是 Rust 语言的一种策略：在具体实现还没有稳定下来之前，我先把接口稳定，实现随着之后的迭代慢慢稳定。

## Cow

* `Cow` 是 Rust 下用于提供写时克隆（Clone-on-Write）的一个智能指针，**它包裹一个只读借用，但如果调用者需要所有权或者需要修改内容，那么它会 clone 借用的数据。**

* 定义：

  ```rust
  pub enum Cow<'a, B> where B: 'a + ToOwned + ?Sized {
    Borrowed(&'a B),
    Owned(<B as ToOwned>::Owned),
  }
  ```

  它是一个 `enum`，可以包含一个对类型 `B` 的只读引用，或者包含对类型 `B` 的拥有所有权的数据。

* 这里引入了两个 trait，首先是 `ToOwned`，在 `ToOwned` trait 定义的时候，又引入了 `Borrow` trait，它们都是 `std::borrow` 下的 trait：

  ```rust
  pub trait ToOwned {
      type Owned: Borrow<Self>;
      #[must_use = "cloning is often expensive and is not expected to have side effects"]
      fn to_owned(&self) -> Self::Owned;
  
      fn clone_into(&self, target: &mut Self::Owned) { ... }
  }
  
  pub trait Borrow<Borrowed> where Borrowed: ?Sized {
      fn borrow(&self) -> &Borrowed;
  }
  ```

  * 首先，`type Owned: Borrow` 是一个带有关联类型的 trait

  * 这里 `Owned` 是关联类型，需要使用者定义，这里 `Owned` 不能是任意类型，它必须满足 `Borrow` trait。例如我们看 `str` 对 `ToOwned` trait 的实现：

    ```rust
    impl ToOwned for str {
        type Owned = String;
        #[inline]
        fn to_owned(&self) -> String {
            unsafe { String::from_utf8_unchecked(self.as_bytes().to_owned()) }
        }
    
        fn clone_into(&self, target: &mut String) {
            let mut b = mem::take(target).into_bytes();
            self.as_bytes().clone_into(&mut b);
            *target = unsafe { String::from_utf8_unchecked(b) }
        }
    }
    ```

    可以看到关联类型 `Owned` 被定义为 `String`，而根据要求，`String` 必须定义 `Borrow`，那这里 `Borrow` 里的泛型变量 `T` 是谁呢？

    `ToOwned` 要求是 `Borrow`，而此刻实现 `ToOwned` 的主体是 `str`，所以 `Borrow<Self>` 是 `Borrow<str>`，也就是说 `String` 要实现 `Borrow<str>`。看代码确实是这样的：

    ```rust
    impl Borrow<str> for String {
        #[inline]
        fn borrow(&self) -> &str {
            &self[..]
        }
    }
    ```

    一张图这几个trait的关系：

    ![img](/images/ayyc5f85c3d9897ddd1acd4c067a5852.jpg)

* 为何 `Borrow` 要定义成一个泛型 trait 呢？搞这么复杂，难道一个类型还可以被借用成不同的引用么？确实是这样：

  ```rust
  use std::borrow::Borrow;
  
  fn main() {
      let s = "hello world!".to_owned();
  
      // 这里必须声明类型，因为 String 有多个 Borrow<T> 实现
      // 借用为 &String
      let r1: &String = s.borrow();
      // 借用为 &str
      let r2: &str = s.borrow();
  
      println!("r1: {:p}, r2: {:p}", r1, r2);
  }
  ```

  `String` 可以被借用为 `&String`，也可以被借用为 `&str`。

* 再来继续看 `Cow`。说它是智能指针，那它自然需要实现 `Deref` trait：

  ```rust
  impl<B: ?Sized + ToOwned> Deref for Cow<'_, B> {
      type Target = B;
  
      fn deref(&self) -> &B {
          match *self {
              Borrowed(borrowed) => borrowed,
              Owned(ref owned) => owned.borrow(),
          }
      }
  }
  ```

  根据 self 是 Borrowed 还是 Owned，我们分别取其内容，生成引用：

  * 对于 `Borrowed`，直接就是引用；
  * 对于 `Owned`，调用其 `borrow()` 方法，获得引用。

  虽然 `Cow` 是一个 `enum`，但是通过 `Deref` 的实现，我们可以获得统一的体验，比如 `Cow<str>`，使用的感觉和 `&str / String` 是基本一致的。

  注意，**这种根据 enum 的不同状态来进行统一分发的方法是第三种分发手段**。之前讲过可以使用泛型参数做静态分发和使用 trait object 做动态分发。

### 使用场景

TODO：







