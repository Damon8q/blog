---
title: "[Rust编程第一课]-02 基础篇"
date: 2022-12-22T11:30:00+08:00
lastmod: 2023-03-09T19:30:00+08:00
author: nange
draft: false
description: "Rust编程第一课 基础部分"

categories: ["programming"]
series: ["rust-first-class"]
series_weight: 2
tags: ["rust"]
---

## 定义变量、函数和数据结构

* ![img](/images/15e5152fe2b72794074cff40041722cb.jpg)

## 流程控制

* ![img](/images/e3a96ae58a98f46f98b56yya6378b26c.jpg)

## 模式匹配

* 假设有这样的枚举：
  ```rust
  #[derive(Debug, Copy, Clone)]
  struct UserId(u64);
  
  #[derive(Debug, Copy, Clone)]
  struct TopicId(u64);
  
  #[derive(Debug, Clone)]
  enum Event {
    Join((UserId, TopicId)),
    Leave((UserId, TopicId)),
    Message((UserId, TopicId, String)),
  }
  ```

  可以这样匹配：

  ```rust
  fn process_event(event: &Event) {
      match event {
          Event::Join((uid, tid)) => println!("user {:?} joined {:?}", uid, tid),
          Event::Leave((uid, tid)) => println!("user {:?} left {:?}", uid, tid),
          Event::Message((_, _, msg)) => println!("broadcast: {}", msg),
      }
  }
  ```

  模式匹配可以对`enum`内部数据进行匹配并赋值。

* 除了`match` 关键字外，还可以使用`if let / while let`做简单匹配，如只关心`Event::Message`：
  ```rust
  fn process_event(event: &Event) {
      if let Event::Message((_, _, msg)) = event {
          println!("broadcast: {}", msg);
      }
  }
  ```

  Rust 的模式匹配是一个很重要的语言特性，被广泛应用在状态机处理、消息处理和错误处理中。

## 错误处理

* Rust没有Java等语言中的异常处理，而是把错误封装在枚举类型中，同时提供了`?`操作符来传播错误

* `Result<T, E>`是泛型数据结构，`T`代表成功执行返回的数据类型，`E`代表错误类型

* 示例：
  ```rust
  use std::fs;
  
  fn main() {
    let url = "https://www.rust-lang.org/";
    let output = "rust.md";
    
    println!("Fetching url: {}", url);
    let body = reqwest::blocking::get(url).unwrap().text().unwrap();
  
    println!("Converting html to markdown...");
    let md = html2md::parse_html(&body);
  
    fs::write(output, md.as_bytes()).unwrap();
    println!("Converted markdown has been saved in {}.", output);
  }
  ```

  如上，如果直接调用`Result<T, E>`的`unwrap()`方法，则表示只关心成功返回的结果，如果出错，程序会`panic`终止。

  如果想让错误传播，可把`unwrap()`换成`?`操作符，并让`main`返回一个`Result`类型，如：

  ```rust
  use std::fs;
  
  fn main() -> Result<(), Box<dyn std::error::Error>> {
      let url = "https://www.rust-lang.org/";
      let output = "rust.md";
  
      println!("Fetching url: {}", url);
      let body = reqwest::blocking::get(url)?.text()?;
  
      println!("Converting html to markdown...");
      let md = html2md::parse_html(&body);
  
      fs::write(output, md.as_bytes())?;
      println!("Converted markdown has been saved in {}.", output);
  
      Ok(())
  }
  ```

* 更多关于错误处理的方式，后续再详细说明

## 项目组织

* 当代码规模很大时，需要分文件分目录来组织代码，此时就需要使用`mod`来组织代码
* 具体：在项目的入口文件`lib.rs / main.rs`里，用`mod`来声明要加载的其他代码文件。如果模块内容很多，可以在该目录下放一个`mod.rs`引入该模块的其他文件，这样就可以用`mod + 目录名`引入这个模块了。如下图所示：
  ![img](/images/8eff27daa16a2bab514590f0b567341d.jpg)

* 在Rust里，**一个项目也被称为一个crate**

  * 通过`cargo new <name> --lib` 创建一个库

  * crate代码改变时，crate需要重新编译

  * crate里，除了源代码，还可以包含单元测试和集成测试代码

  * 单元测试一般放在被测试代码相同的文件中，使用条件编译`#[cfg(test)]`确保只在测试环境下编译，如：
    ```rust
    #[cfg(test)]
    mod tests {
        #[test]
        fn it_works() {
            assert_eq!(2 + 2, 4);
        }
    }
    ```

  * 集成测试一般放在`tests`目录下，和`src`平行。集成测试只能测试`crate`下的公开接口，编译时编译成单独的可执行文件
  * 使用`cargo test`运行测试用例

* 当代码规模继续增长，把所有代码都放在同一个`crate`中不是一个好注意，因为任何代码修改都会造成`crate`重新编译，这样效率很低。**此时就需要使用Workspace。**

  * 一个Workspace可以包含一到多个crates，当代码改变时，只有涉及到的crates才需要重新编译
  * 构建一个Workspace时，需先在某个目录生成一个如下图所示的`Cargo.toml`，包含workspace里所有的crates，然后可以使用`cargo new`生成对应的crates：
    ![img](/images/2bf542e266197e04ededc5c4a6e6cf62.jpg)
  * 更多相关细节，在后续章节补充

## 所有权

### 为什么Rust要创建所有权概念

* **变量在函数调用时发生了什么**

  ```rust 
  
  fn main() {
      let data = vec![10, 42, 9, 8];
      let v = 42;
      if let Some(pos) = find_pos(data, v) {
          println!("Found {} at {}", v, pos);
      }
  }
  
  fn find_pos(data: Vec<u32>, v: u32) -> Option<usize> {
      for (pos, item) in data.iter().enumerate() {
          if *item == v {
              return Some(pos);
          }
      }
      
      None
  }
  ```

  上面这段代码在其他大部分语言中，都是像下图所示：

  ![img](/images/f0989fa8611db83b79500060e8cd682f.jpg)

  也就是变量在栈上的部分，会被复制一份，变成另一个变量，然后指向同样的堆空间。相当于每把`data`作为参数传递一次，堆上的内存就多一次引用。

  **这样做的问题在于：** 这些引用会做什么操作，不得而知，也无从限制；堆内存什么时候能够释放，很难厘清，取决于最后一个引用什么时候结束。看似一个简单的函数调用，给内存管理带来了极大的麻烦。

  **其他大部分语言对堆内存多次引用问题的解决方案如下：**

  * C/C++ 要求开发者手动处理。这非常不便，容易出错。
  * Java等语言使用追踪式GC。通过定期扫描堆上数据还有没有人引用，来提开发者管理内存，这样方便，但是GC可能带来STW(Stop the World)问题。
  * ObjC/Swift 使用自动引用计数(ARC)。在编译时自动添加维护引用计数的代码，但这样同样有一定的运行时性能损耗。

  其他语言都是从管理引用角度思考的，都有各自的弊端。**而Rust是从限制引用行为本身角度思考的。**

### Rust的解决方案

* 一个值只能被一个变量所拥有，这个变量被称为所有者

* 一个值同一时刻只能有一个所有者。变量赋值，参数传递，函数返回等行为会把值的所有权发生转移。这就是Move语义，Rust从C++那里借鉴了这个概念。

* 当所有者离开作用域，其拥有的值被丢弃，内存得到释放

* 在Rust所有权下，上述代码的引用问题将像下面这样被解决：

  ![img](/images/fe810cf1616bce15f53bcf6d28d7f864.jpg)

  `data`被移动到`find_pos()`后，就失效了，编译器会保证随后的代码无法访问这个变量（如果出现后续继续访问的情况，编译即报错）。

* 但实际场景下，我们常常想`data`传递给`find_pos()`后，后续还想继续访问`data`，该怎么办呢？Rust提供了两种方案：

  * 除Move语义外，Rust还提供了**Copy语义**。如果一个数据结构实现了`Copy trait`，那么在赋值和传参时，值会自动按位拷贝。这样不会发生值的所有权转移。
  * 如果无法使用Copy语义，则可以使用Rust的**借用**模式。
  
* **Copy语义和Copy trait：**

  * 实现了Copy trait的类型，就符合Copy语义，在赋值，传参等时，值会自动按位拷贝。

  * 哪些类型实现了Copy trait呢？我们可以给自己的自定义类型实现Copy trait吗？

  * 基础类型已经实现了Copy trait，包括：

    `bool`, `char`, `i8`, `i16`..., `u8`, `u16`..., `usize`,

    `fn()` 函数也实现了Copy trait，本质可等价于一个指针

    `*const String`, `*mut String`，原始指针类型实现了Copy trait

    `&[Vec<u8>]`, `&String`, `&str`，不可变引用类型，实现了Copy trait。可变引用则没有实现Copy

    `[u8; 4]`, `(&str, &str)`，数组和元组，其值如果实现了Copy trait，那么数组和元组本身就实现了Copy trait

  * 给自定义类型实现Copy trait：

    * 可以给自定义类型添加`#[derive(Copy, Clone)]`

      这里之所以要同时派生`Clone`，是因为`Copy` 继承自`Clone`，所以类型要实现`Copy`，必须先实现`Clone`。

    * 手动实现`Copy`

      ```rust
      struct MyStruct;
      
      impl Copy for MyStruct { }
      
      impl Clone for MyStruct {
          fn clone(&self) -> MyStruct {
              *self
          }
      }
      ```

      显然通过自动派生的方式更加方便快捷。

    * 实现`Copy` 是有严格限制的，并不是所有类型都能实现`Copy`，不管是派生的方式还是手动实现都是一样的结果。要能实现`Copy`，要求类型所有成员都已经实现`Copy`。

* 除了实现`Copy`，还可以采用**借用(Borrow)**模式

  * Rust中引用和借用就是一个意思，通过`& 或者 &mut`来实现

  * 引用的赋值和传递不会改变值的所有权，引用实现了`Copy` trait

  * 引用在本质上是一个受控的指针：表现在**引用(借用)不能超过值的生存期**。违背了这个限制，编译将报错。而对于原始指针则没有这个限制。

  * 堆内存可以使用栈内存的引用吗？

    这是一个有迷惑性的问题。本质上是在问，这种情况下，如何保证内存安全，不会出现如悬垂引用等问题。

    ```rust
    fn main() { 
        let mut data: Vec<&u32> = Vec::new(); 
        let v = 42; 
        data.push(&v); 
        println!("data: {:?}", data);
    }
    ```

    `data`明显是放在堆上的，引用了栈上的`v`，上面的代码是OK的，因为`v`的声明周期和`data`的声明周期一样长。不会出现悬垂引用。但像下面的常见就会编译报错：

    ```rust
    fn main() {
        let mut data: Vec<&u32> = Vec::new();
        push_local_ref(&mut data);
        println!("data: {:?}", data);
    }
    
    fn push_local_ref(data: &mut Vec<&u32>) {
        let v = 42;
        data.push(&v);
    }
    ```

    **核心只需要关心调用栈的生命周期。**

  * 可变引用/借用

    * 在同一个上下文中，不能有多个可变引用。下面的代码将编译报错：

      ```rust
      fn main() {
          let mut data = vec![1, 2, 3];
      
          for item in data.iter_mut() {
              data.push(*item + 1);
          }
      }
      ```

      上面的代码是危险的，可能发送死循环等问题，好在Rust编译就不会通过。

    * 一个可变引用和若干只读引用，也是不允许的。如下面的代码将会报错：

      ```rust
      fn main() {
          let mut data = vec![1, 2, 3];
          let data1 = vec![&data[0]];
          println!("data[0]: {:p}", &data[0]);
      
          for i in 0..100 {
              data.push(i);
          }
      
          println!("data[0]: {:p}", &data[0]);
          println!("boxed: {:p}", &data1);
      }
      ```

      往`data`中push数据过程中，可能发生内存重现分配，造成`data1`中保存的`&data[0]`失效，导致内存安全问题。

    * 总结：对可变引用的限制：
      * **在一个作用域内，只允许一个活跃的可变引用**。所谓活跃，就是真正被使用来修改数据的可变引用，如果只是定义了，却没有使用或者当作只读引用使用，不算活跃。
      * 在一个作用域内，活跃的可变引用（写）和只读引用（读）是互斥的，不能同时存在。

​			













