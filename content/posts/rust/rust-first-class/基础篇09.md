---
title: "[Rust编程第一课]-010 基础篇09-闭包"
date: 2023-04-20T16:15:00+08:00
lastmod: 2023-04-20T19:00:00+08:00
author: nange
draft: false
description: "Rust编程第一课 基础部分"

categories: ["programming"]
series: ["rust-first-class"]
series_weight: 10
tags: ["rust"]
---

* 闭包是一个很重要的工具，可以很方便地以函数式编程的方式来撰写代码。因为闭包可以作为参数传递给函数，可以作为返回值被函数返回，也可以为它实现某个 trait，使其能表现出其他行为，而不仅仅是作为函数被调用。
* 这些都是怎么做到的？闭包的本质是什么？

## 闭包的定义

* 闭包会根据内部的使用情况，捕获环境中的自由变量。在 Rust 里，闭包可以用 `|args| {code}` 来表述，下图中闭包 `c` 捕获了上下文中的 `a` 和 `b`，并**通过引用来使用**这两个自由变量：

  ![img](/images/6060b99f222ef6e435c9fe7c83f46593.jpg)

* 除了用引用来捕获自由变量之外，还有另外一个方法使用 `move` 关键字 `move |args| {code}` 。创建新线程的 `thread::spawn`，它的参数就是一个闭包：

  ```rust
  pub fn spawn<F, T>(f: F) -> JoinHandle<T> 
  where
      F: FnOnce() -> T,
      F: Send + 'static,
      T: Send + 'static,
  ```

  * `F: FnOnce() → T`，表明 `F` 是一个接受 0 个参数、返回 `T` 的闭包。`FnOnce` 稍后再说；
  * `F: Send + 'static`，说明闭包 `F` ，需要静态生命周期的引用或者拥有所有权的对象，并且它还能被移动给另一个线程；
  * `T: Send + 'static`，说明闭包 `F` 返回数据结构 `T`，需要静态生命周期的引用或者拥有所有权的对象，并且它还能被移动给另一个线程。

  **关于第二点：一个闭包，它不就是一段代码 + 被捕获的变量么？需要静态生命周期或者拥有所有权是什么意思？**

  * 拆开看。代码自然是静态生命周期了，那么是不是意味着被捕获的变量，需要静态生命周期或者拥有所有权？

  * 的确如此。要求被捕获的变量也要是静态生命周期或拥有所有权。如下代码：

    ```rust
    use std::thread;
    
    fn main() {
        let s = String::from("hello world");
    
        let handle = thread::spawn(move || {
            println!("moved: {:?}", s);
        });
    
        handle.join().unwrap();
    }
    ```

  * **还有一个重要的问题：上面代码中的变量`s`为什么满足`'static'`约束呢？ 按道理`s`的生命周期也不是整个进程啊？** 

    这个问题想了好久，找了写资料终于明白了：为什么会存在生命周期的标注和约束？是因为怕对引用的误用，造成出现悬垂指针的问题。换句话说，**生命周期标注是用来限制引用类型变量的**。再换句话说：**所有拥有所有权，并且不包含引用类型字段的对象，一定是符合`'static`生命周期的**。

    参考连接：[[Why does thread::spawn need static lifetime for generic bounds?](https://users.rust-lang.org/t/why-does-thread-spawn-need-static-lifetime-for-generic-bounds/4541)]

## 闭包本质上是什么？

* 在官方的 Rust reference 中，有这样的定义：

  > A closure expression produces a closure value with a unique, anonymous type that cannot be written out. A closure type is approximately equivalent to a struct which contains the captured variables.

  闭包是一种匿名类型，一旦声明，就会产生一个新的类型，但这个类型无法被其它地方使用。这个类型就像一个结构体，会包含所有捕获的变量。



























