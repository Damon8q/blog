---
title: "[Rust编程第一课]-01 前置基础"
date: 2022-12-06T18:00:00+08:00
lastmod: 2022-12-06T18:00:00+08:00
author: nange
draft: false
description: "Rust编程第一课 前置基础"

categories: ["programming"]
series: ["rust-first-class"]
series_weight: 1
tags: ["rust"]
---

## 内存：值放堆上还是栈上

* ```rust
  let s = "hello world".to_string();
  ```

* 上面这段代码："hello world" 作为一个字符串常量（string literal），在编译时被存入可执行文件的 .RODATA 段（Linux ELF文件格式，详细见参考资料1），在程序加载时，获得一个固定的内存地址。

* 执行`"hello world".to_string()`时，在堆上，一块新的内存被分配出来，并把"hello world"逐个字节拷贝过去。

* 当把堆上的数据赋值给`s`时，`s`作为分配在栈上的变量，它需要知道堆上的内存地址；另外由于堆上的数据大小不确定可增长，还需要知道它的长度以及总容量。

* 最终，**为了表述这个字符串，需要使用三个word**：一个表示指针、一个表示字符串当前长度、一个表示这片内存的总容量。在64位系统下，是24字节。下面的图会更直观：

* ![img](/images/a7e7f2334460f15f9afd04ebd710b54c.jpg)

### 数据什么时候可以放栈上？什么时候需要放堆上？

* **栈**

  * 一个函数被调用时，一块连续的内存会在栈顶被分配出来，这块内存被称为“帧(frame)”。

  * 调用过程中，一个新的帧会分配足够的空间存储寄存器的上下文。在函数里使用到的通用寄存器(值)会在栈保存一个副本，当这个函数调用结束，通过副本，可以恢复出原本的寄存器上下文，就像什么都没有经历一样。调用过程就像下图：

  * ![img](/images/cce3c36426cd910feaee4c4ccb3afcbc.jpg)

  * 上图中：FP 是 frame pointer，指向栈帧的起始位置。还有一个 SP（stack pointer）指向栈顶，它会随着栈的操作而变化。在开一个新的栈帧的时候，在栈顶会压入 callee 函数的参数，caller 返回地址，以及 caller FP。（详细见参考资料2,3）

  * **函数运行怎么确定究竟需要多大的帧呢？**

    * 编译器在编译和优化代码时，一个函数是最小的编译单元
    * 在此函数内，编译器得知道要用哪些寄存器、栈上要放哪些局部变量，而这些都要在编译期确定下来
    * 所以编译器就需要明确每个局部变量的大小，以便预留空间。也就是说，在编译时一切无法确定大小或者大小可以改变的数据，都无法安全的放在栈上，最好放在堆上。

  * 举例：

    * ```rust
      fn say_name(name: String) {}
      ```

    * 字符串的数据结构，在编译时无法确定大小，运行时执行到具体的代码才知道大小。所以无法把字符串本身放在栈上，只能先将其放在堆上，然后在栈上分配对应的指针，引用堆上的内存。

  * **放栈上的问题**：

    * 栈上的内存分配是非常高效的。只需要改动栈指针(stack pointer)，就可以预留空间；把栈指针改回来，预留空间就被释放掉。这个过程只是动动寄存器(ESP, EBP寄存器)，不涉及额外计算、系统调用，效率极高。
    * 









## 参考资料

1. [深入理解程序构造](https://www.jianshu.com/p/1a65293d722e)
1. [函数调用过程中栈到底是怎么压入和弹出的？](https://www.zhihu.com/question/22444939/answer/705117359)
1. [Understanding stack frame of function call in C/C++?](https://softwareengineering.stackexchange.com/questions/195385/understanding-stack-frame-of-function-call-in-c-c)