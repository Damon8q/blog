---
title: "[Rust编程第一课]-18 并发篇01-并发处理：从atomics到Channel，Rust都提供了什么工具？"
date: 2023-05-31T15:00:00+08:00
lastmod: 2023-05-29T19:00:00+08:00
author: nange
draft: false
description: "Rust编程第一课 并发部分"

categories: ["programming"]
series: ["rust-first-class"]
series_weight: 18
tags: ["rust"]
---

## Atomic

* Compare-and-swap(CAS)：`compare_exchange` 是 Rust 标准库中 `std::sync::atomic` 模块下原子类型（如 `AtomicBool`、`AtomicIsize`、`AtomicUsize` 等）的一个方法。它用于在多线程环境中执行原子的比较和交换操作。`compare_exchange` 方法接受两个参数：一个是期望的当前值，另一个是要设置的新值。如果原子类型的当前值等于期望值，那么它会将新值设置为当前值。否则，它不会更改当前值。无论操作是否成功，`compare_exchange` 都会返回原子类型的旧值。示例：

  ```rust
  use std::{
      sync::{
          atomic::{AtomicUsize, Ordering},
          Arc,
      },
      thread,
  };
  
  fn main() {
      let counter = Arc::new(AtomicUsize::new(0));
      let mut handles = vec![];
  
      for _ in 0..10 {
          let counter_cloned = counter.clone();
          let handle = thread::spawn(move || {
              for _ in 0..1000 {
                  let mut old_value = counter_cloned.load(Ordering::SeqCst);
                  let mut new_value;
  
                  loop {
                      new_value = old_value + 1;
  
                      match counter_cloned.compare_exchange(
                          old_value,
                          new_value,
                          Ordering::SeqCst,
                          Ordering::SeqCst,
                      ) {
                          Ok(_) => break,
                          Err(actual) => old_value = actual,
                      }
                  }
              }
          });
  
          handles.push(handle);
      }
  
      for handle in handles {
          handle.join().unwrap();
      }
  
      println!("Counter: {}", counter.load(Ordering::SeqCst));
  }
  ```

* `Ordering`枚举是什么？

  `Ordering` 是 Rust 中的一个枚举类型，用于表示原子操作的内存顺序。内存顺序决定了编译器和硬件对原子操作的优化程度。在 Rust 中，有五种内存顺序可供选择：

  1. `Ordering::Relaxed`: 最宽松的内存顺序，只保证原子操作本身不会被中断。编译器和硬件可以自由地对操作进行优化，可能导致操作在不同线程间的顺序不一致。适用于不关心操作顺序的场景。
  2. `Ordering::Release`: 用于存储操作，确保在此操作之前的所有操作不会被重排序到此操作之后。适用于需要确保某些操作在释放锁之前完成的场景。
  3. `Ordering::Acquire`: 用于加载操作，确保在此操作之后的所有操作不会被重排序到此操作之前。适用于需要确保在获取锁之后才执行某些操作的场景。
  4. `Ordering::AcqRel`: 结合了 `Acquire` 和 `Release` 的语义，适用于需要同时确保加载和存储操作之间的顺序的场景。
  5. `Ordering::SeqCst`: 最严格的内存顺序，保证所有线程看到的操作顺序一致。通常用于需要确保全局顺序的场景，但性能可能受到影响。

* 举例说明`Ordering`枚举：

  1. `Ordering::Relaxed`

     ```rust
     use std::sync::atomic::{AtomicUsize, Ordering};
     use std::thread;
     
     static COUNTER: AtomicUsize = AtomicUsize::new(0);
     
     fn main() {
         let mut handles = vec![];
     
         for _ in 0..10 {
             let handle = thread::spawn(|| {
                 for _ in 0..1000 {
                     COUNTER.fetch_add(1, Ordering::Relaxed);
                 }
             });
             handles.push(handle);
         }
     
         for handle in handles {
             handle.join().unwrap();
         }
     
         println!("Counter: {}", COUNTER.load(Ordering::Relaxed));
     }
     
     ```

     在这个例子中，我们使用一个全局的 `AtomicUsize` 作为计数器。我们创建了 10 个线程，每个线程对计数器进行 1000 次增加操作。由于我们使用 `Relaxed` 顺序，编译器和硬件可以对这些操作进行优化，但不能保证操作的全局顺序。在这种情况下，我们关心的是最终的计数值，而不是操作的顺序，所以使用 `Relaxed` 是合适的。

  2. `Ordering::Release` 和 `Ordering::Acquire`

     ```rust
     use std::sync::atomic::{AtomicBool, Ordering};
     use std::sync::Arc;
     use std::thread;
     use std::time::Duration;
     
     fn main() {
         let flag = Arc::new(AtomicBool::new(false));
         let flag_clone = Arc::clone(&flag);
     
         let producer = thread::spawn(move || {
             // Do some work
             thread::sleep(Duration::from_secs(1));
             flag.store(true, Ordering::Release);
         });
     
         let consumer = thread::spawn(move || {
             while !flag_clone.load(Ordering::Acquire) {
                 // Wait for the flag to be set
             }
             println!("Flag is set!");
         });
     
         producer.join().unwrap();
         consumer.join().unwrap();
     }
     
     ```

     在这个例子中，我们使用一个 `AtomicBool` 作为标志。生产者线程在完成一些工作后将标志设置为 `true`，使用 `Ordering::Release` 保证在此操作之前的所有操作不会被重排序到此操作之后。消费者线程等待标志被设置，使用 `Ordering::Acquire` 保证在此操作之后的所有操作不会被重排序到此操作之前。这样可以确保生产者线程的工作在消费者线程读取标志之前完成。





































