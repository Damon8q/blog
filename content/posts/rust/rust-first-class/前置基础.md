---
title: "[Rust编程第一课]-01 前置基础"
date: 2022-12-06T18:00:00+08:00
lastmod: 2022-12-21T16:54:00+08:00
author: nange
draft: false
description: "Rust编程第一课 前置基础"

categories: ["programming"]
series: ["rust-first-class"]
series_weight: 1
tags: ["rust"]
---

## 内存：值放堆上还是栈上

* ```rust
  let s = "hello world".to_string();
  ```

* 上面这段代码："hello world" 作为一个字符串常量（string literal），在编译时被存入可执行文件的 .RODATA 段（Linux ELF文件格式，详细见参考资料1），在程序加载时，获得一个固定的内存地址。

* 执行`"hello world".to_string()`时，在堆上，一块新的内存被分配出来，并把"hello world"逐个字节拷贝过去。

* 当把堆上的数据赋值给`s`时，`s`作为分配在栈上的变量，它需要知道堆上的内存地址；另外由于堆上的数据大小不确定可增长，还需要知道它的长度以及总容量。

* 最终，**为了表述这个字符串，需要使用三个word**：一个表示指针、一个表示字符串当前长度、一个表示这片内存的总容量。在64位系统下，是24字节。下面的图会更直观：

* ![img](/images/a7e7f2334460f15f9afd04ebd710b54c.jpg)

### 数据什么时候可以放栈上？什么时候需要放堆上？

* **栈**

  * 一个函数被调用时，一块连续的内存会在栈顶被分配出来，这块内存被称为“帧(frame)”。

  * 调用过程中，一个新的帧会分配足够的空间存储寄存器的上下文。在函数里使用到的通用寄存器(值)会在栈保存一个副本，当这个函数调用结束，通过副本，可以恢复出原本的寄存器上下文，就像什么都没有经历一样。调用过程就像下图：

  * ![img](/images/cce3c36426cd910feaee4c4ccb3afcbc.jpg)

  * 上图中：FP 是 frame pointer，指向栈帧的起始位置。还有一个 SP（stack pointer）指向栈顶，它会随着栈的操作而变化。在开一个新的栈帧的时候，在栈顶会压入 callee 函数的参数，caller 返回地址，以及 caller FP。（详细见参考资料2,3）

  * **函数运行怎么确定究竟需要多大的帧呢？**

    * 编译器在编译和优化代码时，一个函数是最小的编译单元
    * 在此函数内，编译器得知道要用哪些寄存器、栈上要放哪些局部变量，而这些都要在编译期确定下来
    * 所以编译器就需要明确每个局部变量的大小，以便预留空间。也就是说，在编译时一切无法确定大小或者大小可以改变的数据，都无法安全的放在栈上，最好放在堆上。

  * 举例：

    * ```rust
      fn say_name(name: String) {}
      ```

    * 字符串的数据结构，在编译时无法确定大小，运行时执行到具体的代码才知道大小。所以无法把字符串本身放在栈上，只能先将其放在堆上，然后在栈上分配对应的指针，引用堆上的内存。

  * **放栈上的问题**：

    * 栈上的内存分配是非常高效的。只需要改动栈指针(stack pointer)，就可以预留空间；把栈指针改回来，预留空间就被释放掉。这个过程只是动动寄存器(ESP, EBP寄存器)，不涉及额外计算、系统调用，效率极高。
    * 但栈空间是大小是很有限的，如果把大数据放到栈上，容易发生栈溢出。

* **堆**

  * 当需要动态大小内存时，只能使用堆。如可变长度数组、列表、哈希表、字典等。
  * **放堆上的问题：**
    * 手动管理内存，容易内存泄露
    * 被多线程调用栈引用，改动内存需要加锁，否则会出现各自内存问题，如越界等
    * 堆上内存被释放，但栈上指针没有清空，则出现使用已释放内存问题（use after free），这是严重的内存问题

  * GC、ARC如何解决：
    * 常用GC算法通过定期标记，找到不再被引用的对象，然后将其清理，来自动管理内存
    * 而Swift则通过：自动引用计数（Automatic Reference Counting），在编译时，为每个函数插入retain/release语句来自动维护堆上对象的引用计数，当引用计数为零时，release语句就释放对象
    * 从效率上来讲，GC效率更高，吞吐量更大。但GC释放内存的时机不确定，释放时容易造成STW(Stop the world)，造成代码执行延迟


### 小结

栈上存放的数据是静态的，固定大小，固定生命周期的；堆上存放数据是动态的，不固定大小，不固定生命周期的。

## 编程中的其他基本概念

### 数据

* 数据是程序操作的对象
* **值和类型：**
  * 类型是对值的区分。其包含了值在内存的长度、对齐以及可以进行的操作。比如`64u8`是`u8`类型，一个字节大小，取值范围在`0~255`
  * 值无法脱离具体的类型讨论。同样内存中的字节`0x40`，如果类型是`char`，其含义就不是64，而是`@`符号
  * 类型通常分为原生类型和组合类型两大类。原生类型（primitive type）是编程语言提供的最基础的数据类型，大小固定，可以被分配到栈上；组合类型（composite type）通常是结构体、枚举等

* **指针和引用：**
  * 一个值被存储在内存中的某个位置，这个位置对应一个内存地址。而指针是一个持有内存地址的值，可以通过解引用来访问对应的值，理论上可以解引用到任意数据类型
  * 引用和指针很类似，不同的是，引用的解引用访问是受限的，只能解引用到它引用的数据类型，不能用作它用
  * 根据指向的数据不同，某些引用除了需要一个指针指向内存地址以外，还需要长度和其他信息
* **代码：**
  * 代码是程序运行的主体。主要包含：函数、闭包、接口和虚表
  * **函数、方法和闭包：**
    * 函数是完成某个功能的一组相关语句和表达式的封装。也是对代码重复行为的抽象。函数往往还可以作为参数传递，返回值，或者复合类型的组成部分
    * 在对象中定义的函数，被成为方法
    * 闭包是将函数和其环境一起存储的一种数据结构
* **接口和虚表：**
  * 接口反映了系统设计者对系统的抽象理解。作为一个抽象层，接口将使用方和实现方隔离开来，使两者不直接有依赖关系，大大提高了复用性和扩展性
  * 在运行期使用接口时，代码就具备了运行时对态的能力。在运行时，一旦使用了关于接口的引用，变量原本的类型被抹去，因此在生成这个引用时，需要构建胖指针，除了指向数据本身外，还需要指向一张涵盖了这个接口所支持方法的列表，这个列表就是虚表(virtual table)。如下图：
    ![img](/images/27f671936d44d08d837fbf68baee21f9.jpg)

### 运行方式

* **并发与并行：**
  * 并发是一种能力，而并行是一种手段。当系统拥有了并发的能力后，代码如果跑在多个 CPU core 上，就可以并行运行。

* **同步和异步：**
  * 同步是指一个任务开始执行后，后续的操作会阻塞，直到这个任务结束
  * 然而在遭遇 I/O 处理时，高效 CPU 指令和低效 I/O 之间的巨大鸿沟。I/O 操作的访问速度比内存访问低了两个数量级，因此操作系统为应用提供了异步IO，在IO处理完毕前，CPU可以处理其他任务
  * 在异步操作里，异步处理完成后的结果，一般用 Promise 来保存，它是一个对象：
    * 初始状态，Promise 还未运行；
    * 等待（pending）状态，Promise 已运行，但还未结束；
    * 结束状态， Promise 成功解析出一个值，或者执行失败。
  * 在很多支持异步的语言中，Promise 也叫 Future / Delay / Deferred 等。除了这个词以外，我们也经常看到 async/await 这对关键字。
  * async 定义了一个可以并发执行的任务，而 await 则触发这个任务并发执行
  * async/await 是一个语法糖（syntactic sugar），它使用状态机将 Promise 包装起来，让异步调用的使用感觉和同步调用非常类似，也让代码更容易阅读

### 编程范式

*  **数据结构的泛型：** 也被称为参数化类型或参数多态

  * ```rust
    struct Connection<S> {
        io: S,
        state: State,
    }
    ```

  * 它有一个参数 S，其内部的域 io 的类型是 S，S 具体的类型只有在使用 Connection 的上下文中才得到绑定

  * 可以把它理解成产生类型的函数，**在“调用”时，它接受若干个使用了具体类型的参数，返回携带这些类型的类型**。比如为 S 提供 TcpStream 这个类型，那么就产生 Connection这个类型，其中 io 的类型是 TcpStream。

  * 如果S都是任意类型，就无法知道S有什么行为，因此常常还对S进行接口约束，后续再做详细介绍

    * 数据结构的泛型是一种高级抽象，好处是可以延迟绑定，让数据结构的通用性更强，适用场合更广阔

* **代码的泛型化：**
  * 泛型编程的另一个层面是使用泛型结构后代码的泛型化。当使用泛型结构编写代码时，相关的代码也需要额外的抽象。最常见的就是C++的模板。



## 参考资料

1. [深入理解程序构造](https://www.jianshu.com/p/1a65293d722e)
1. [函数调用过程中栈到底是怎么压入和弹出的？](https://www.zhihu.com/question/22444939/answer/705117359)
1. [Understanding stack frame of function call in C/C++?](https://softwareengineering.stackexchange.com/questions/195385/understanding-stack-frame-of-function-call-in-c-c)