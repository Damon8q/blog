---
title: "[Rust编程第一课]-02 基础篇"
date: 2022-12-22T11:30:00+08:00
lastmod: 2023-03-08T19:30:00+08:00
author: nange
draft: false
description: "Rust编程第一课 基础部分"

categories: ["programming"]
series: ["rust-first-class"]
series_weight: 2
tags: ["rust"]
---

## 定义变量、函数和数据结构

* ![img](/images/15e5152fe2b72794074cff40041722cb.jpg)

## 流程控制

* ![img](/images/e3a96ae58a98f46f98b56yya6378b26c.jpg)

## 模式匹配

* 假设有这样的枚举：
  ```rust
  #[derive(Debug, Copy, Clone)]
  struct UserId(u64);
  
  #[derive(Debug, Copy, Clone)]
  struct TopicId(u64);
  
  #[derive(Debug, Clone)]
  enum Event {
    Join((UserId, TopicId)),
    Leave((UserId, TopicId)),
    Message((UserId, TopicId, String)),
  }
  ```

  可以这样匹配：

  ```rust
  fn process_event(event: &Event) {
      match event {
          Event::Join((uid, tid)) => println!("user {:?} joined {:?}", uid, tid),
          Event::Leave((uid, tid)) => println!("user {:?} left {:?}", uid, tid),
          Event::Message((_, _, msg)) => println!("broadcast: {}", msg),
      }
  }
  ```

  模式匹配可以对`enum`内部数据进行匹配并赋值。

* 除了`match` 关键字外，还可以使用`if let / while let`做简单匹配，如只关心`Event::Message`：
  ```rust
  fn process_event(event: &Event) {
      if let Event::Message((_, _, msg)) = event {
          println!("broadcast: {}", msg);
      }
  }
  ```

  Rust 的模式匹配是一个很重要的语言特性，被广泛应用在状态机处理、消息处理和错误处理中。

## 错误处理

* Rust没有Java等语言中的异常处理，而是把错误封装在枚举类型中，同时提供了`?`操作符来传播错误

* `Result<T, E>`是泛型数据结构，`T`代表成功执行返回的数据类型，`E`代表错误类型

* 示例：
  ```rust
  use std::fs;
  
  fn main() {
    let url = "https://www.rust-lang.org/";
    let output = "rust.md";
    
    println!("Fetching url: {}", url);
    let body = reqwest::blocking::get(url).unwrap().text().unwrap();
  
    println!("Converting html to markdown...");
    let md = html2md::parse_html(&body);
  
    fs::write(output, md.as_bytes()).unwrap();
    println!("Converted markdown has been saved in {}.", output);
  }
  ```

  如上，如果直接调用`Result<T, E>`的`unwrap()`方法，则表示只关心成功返回的结果，如果出错，程序会`panic`终止。

  如果想让错误传播，可把`unwrap()`换成`?`操作符，并让`main`返回一个`Result`类型，如：

  ```rust
  use std::fs;
  
  fn main() -> Result<(), Box<dyn std::error::Error>> {
      let url = "https://www.rust-lang.org/";
      let output = "rust.md";
  
      println!("Fetching url: {}", url);
      let body = reqwest::blocking::get(url)?.text()?;
  
      println!("Converting html to markdown...");
      let md = html2md::parse_html(&body);
  
      fs::write(output, md.as_bytes())?;
      println!("Converted markdown has been saved in {}.", output);
  
      Ok(())
  }
  ```

* 更多关于错误处理的方式，后续再详细说明

## 项目组织

* 当代码规模很大时，需要分文件分目录来组织代码，此时就需要使用`mod`来组织代码
* 具体：在项目的入口文件`lib.rs / main.rs`里，用`mod`来声明要加载的其他代码文件。如果模块内容很多，可以在该目录下放一个`mod.rs`引入该模块的其他文件，这样就可以用`mod + 目录名`引入这个模块了。如下图所示：
  ![img](/images/8eff27daa16a2bab514590f0b567341d.jpg)

* 在Rust里，**一个项目也被称为一个crate**

  * 通过`cargo new <name> --lib` 创建一个库

  * crate代码改变时，crate需要重新编译

  * crate里，除了源代码，还可以包含单元测试和集成测试代码

  * 单元测试一般放在被测试代码相同的文件中，使用条件编译`#[cfg(test)]`确保只在测试环境下编译，如：
    ```rust
    #[cfg(test)]
    mod tests {
        #[test]
        fn it_works() {
            assert_eq!(2 + 2, 4);
        }
    }
    ```

  * 集成测试一般放在`tests`目录下，和`src`平行。集成测试只能测试`crate`下的公开接口，编译时编译成单独的可执行文件
  * 使用`cargo test`运行测试用例

* 当代码规模继续增长，把所有代码都放在同一个`crate`中不是一个好注意，因为任何代码修改都会造成`crate`重新编译，这样效率很低。**此时就需要使用Workspace。**

  * 一个Workspace可以包含一到多个crates，当代码改变时，只有涉及到的crates才需要重新编译
  * 构建一个Workspace时，需先在某个目录生成一个如下图所示的`Cargo.toml`，包含workspace里所有的crates，然后可以使用`cargo new`生成对应的crates：
    ![img](/images/2bf542e266197e04ededc5c4a6e6cf62.jpg)
  * 更多相关细节，在后续章节补充

## 所有权

### 为什么Rust要创建所有权概念

* **变量在函数调用时发生了什么**

  ```rust 
  
  fn main() {
      let data = vec![10, 42, 9, 8];
      let v = 42;
      if let Some(pos) = find_pos(data, v) {
          println!("Found {} at {}", v, pos);
      }
  }
  
  fn find_pos(data: Vec<u32>, v: u32) -> Option<usize> {
      for (pos, item) in data.iter().enumerate() {
          if *item == v {
              return Some(pos);
          }
      }
      
      None
  }
  ```

  上面这段代码在其他大部分语言中，都是像下图所示：

  ![img](/images/f0989fa8611db83b79500060e8cd682f.jpg)

  也就是变量在栈上的部分，会被复制一份，变成另一个变量，然后指向同样的堆空间。相当于每把`data`作为参数传递一次，堆上的内存就多一次引用。

  **这样做的问题在于：** 这些引用会做什么操作，不得而知，也无从限制；堆内存什么时候能够释放，很难厘清，取决于最后一个引用什么时候结束。看似一个简单的函数调用，给内存管理带来了极大的麻烦。

  **其他大部分语言对堆内存多次引用问题的解决方案如下：**

  * C/C++ 要求开发者手动处理。这非常不便，容易出错。
  * Java等语言使用追踪式GC。通过定期扫描堆上数据还有没有人引用，来提开发者管理内存，这样方便，但是GC可能带来STW(Stop the World)问题。
  * ObjC/Swift 使用自动引用计数(ARC)。在编译时自动添加维护引用计数的代码，但这样同样有一定的运行时性能损耗。

  其他语言都是从管理引用角度思考的，都有各自的弊端。**而Rust是从限制引用行为本身角度思考的。**

* **Rust的解决方案**

  * 一个值只能被一个变量所拥有，这个变量被称为所有者

  * 一个值同一时刻只能有一个所有者。变量赋值，参数传递，函数返回等行为会把值的所有权发生转移。这就是Move语义，Rust从C++那里借鉴了这个概念。

  * 当所有者离开作用域，其拥有的值被丢弃，内存得到释放

  * 在Rust所有权下，上述代码的引用问题将像下面这样被解决：

    ![img](/images/fe810cf1616bce15f53bcf6d28d7f864.jpg)

    `data`被移动到`find_pos()`后，就失效了，编译器会保证随后的代码无法访问这个变量（如果出现后续继续访问的情况，编译即报错）。

  * 但实际场景下，我们常常想`data`传递给`find_pos()`后，后续还想继续访问`data`，该怎么办呢？Rust提供了两种方案：

    * 除Move语义外，Rust还提供了**Copy语义**。如果一个数据结构实现了`Copy trait`，那么在赋值和传参时，值会自动按位拷贝。这样不会发生值的所有权转移。
    * 如果无法使用Copy语义，则可以使用Rust的**借用**模式。

















