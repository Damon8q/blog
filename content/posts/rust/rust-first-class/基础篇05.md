---
title: "[Rust编程第一课]-06 基础篇05-那些必须掌握的trait"
date: 2023-04-08T17:30:00+08:00
lastmod: 2023-04-08T19:30:00+08:00
author: nange
draft: false
description: "Rust编程第一课 基础部分"

categories: ["programming"]
series: ["rust-first-class"]
series_weight: 6
tags: ["rust"]
---

## 内存相关：Clone / Copy / Drop

### Clone trait

* `Clone` trait 定义：

  ```rust
  pub trait Clone {
    fn clone(&self) -> Self;
  
    fn clone_from(&mut self, source: &Self) {
      *self = source.clone()
    }
  }
  ```

  `Clone` trait 有两个方法， clone() 和 clone_from() ，后者有缺省实现，所以通常只需要实现 `clone()` 方法即可。 `clone_from()` 有什么作用呢？看起来 `a.clone_from(&b)` ，和 `a = b.clone()` 是等价的。

  其实不是，如果 `a` 已经存在，在 `clone` 过程中会分配内存，那么**用 `a.clone_from(&b)`可以避免内存分配，提高效率。**

* `Clone` trait 可以通过派生宏直接实现，这样能简化不少代码。如果数据结构里，每一个字段都已经实现了 `Clone` trait，则可以用 `#[derive(Clone)]`。如：

  ```rust
  #[derive(Clone, Debug)]
  struct Developer {
    name: String,
    age: u8,
    lang: Language
  }
  
  #[allow(dead_code)]
  #[derive(Clone, Debug)]
  enum Language {
    Rust,
    TypeScript,
    Elixir,
    Haskell
  }
  
  fn main() {
      let dev = Developer {
          name: "Tyr".to_string(),
          age: 18,
          lang: Language::Rust
      };
      let dev1 = dev.clone();
      println!("dev: {:?}, addr of dev name: {:p}", dev, dev.name.as_str());
      println!("dev1: {:?}, addr of dev1 name: {:p}", dev1, dev1.name.as_str())
  }
  ```

* `Clone` 是深度拷贝，栈内存和堆内存一起拷贝。
* `clone` 方法的接口是 `&self`，这在绝大多数场合下都是适用的。但对 `Rc` 这样在 `clone()` 时维护引用计数的数据结构，`clone()` 过程中会改变自己，所以要用 `Cell` 这样提供内部可变性的结构来进行改变。

### Copy trait

* `Copy` trait 定义：

  ```rust
  pub trait Copy: Clone {}
  ```

  `Copy` trait的定义比较特殊，除了“继承”自`Clone` trait，本身并没有任何额外的方法。

* 这样的 trait 虽然没有任何行为，但它可以用作 trait bound 来进行类型安全检查，所以我们管它叫标记 trait。

  用于表示类型的值可以通过简单的内存复制来创建新的实例。换句话说，当类型实现了 `Copy` trait 时，它表示这个类型在进行复制操作时不需要执行特殊的逻辑，例如调用析构函数或执行深拷贝。

* 和 `Clone` 一样，如果数据结构的所有字段都实现了 `Copy`，也可以用 `#[derive(Copy)]` 宏来为数据结构实现 `Copy`。如：

  ```rust
  #[derive(Clone, Copy, Debug)]
  struct Developer {
    name: String,
    age: u8,
    lang: Language
  }
  
  #[derive(Clone, Copy, Debug)]
  enum Language {
    Rust,
    TypeScript,
    Elixir,
    Haskell
  }
  ```

  但上面的代码会报错，因为 `String` 类型没有实现 `Copy`。 如果类型实现了 `Copy`，那么在赋值、函数调用的时候，值会被拷贝，否则所有权会被移动。

  所以上面的代码 `Developer` 类型在做参数传递时，会执行 `Move` 语义，而 `Language` 会执行 `Copy` 语义。

* 在所有权可变 / 不可变引用的时候提到，不可变引用实现了 `Copy`，而可变引用 `&mut T` 没有实现 `Copy`。为什么是这样？

  因为如果可变引用实现了 `Copy` trait，那么把一个可变引用赋值给另一个变量时，就会违背所有权规则：同一个作用域下只能有一个可变引用。

* **关于Copy trait的一些问题**：

  1. 为什么`Copy` 需要继承 `Clone` ?

     * 一致性：当一个类型实现了 `Copy` trait 时，它意味着该类型可以进行简单的内存复制，因此实现 `Clone` trait 是合理的。这保证了一致性，即所有可复制的类型都可以使用 `clone` 方法，无论它们是通过实现 `Copy` 还是仅仅实现 `Clone` trait。
     * 易用性：因为 `Copy` trait 自动继承了 `Clone` trait，所以当你需要实现 `Copy` 时，你只需要手动实现 `Clone` trait。这样一来，当你调用 `clone` 方法时，编译器会为 `Copy` 类型生成一个简单的内存复制操作，而不需要你手动实现两个 trait。

  2. 可以为自定义类型手动实现`Copy`类型吗？

     可以，但无必要。

     原因是：第一对于一个自定义类型来说，如果其所有的字段都已经实现了`Copy`，那么就可以通过`derive`自动派生`Copy`的实现，这样简单方便，如果去手动实现，显得很多余。

     第二如果自定义类型某些字段没有或者无法实现`Copy`（如包含所有权的字段`String`），那么此类型就无法实现`Copy`，不管是手动或者派生都不行。

  3. `Copy` 所指的内存复制，是特指栈内存复制吗？

     大部分情况是，但也不完全是。比如：

     ```rust
     #[derive(Copy, Clone)]
     struct Point {
         x: i32,
         y: i32,
     }
     
     fn main() {
         let p1 = Point { x: 1, y: 2 };
     	let p2 = p1; // 执行栈内存复制
         
         let p1 = Box::new(Point { x: 1, y: 2 });
     	let p2 = *p1; // 执行堆内存复制
     }
     ```

     第二种情况：`p1` 是一个指向堆上的 `Point` 实例的指针，当我们解引用 `p1` 并将其赋值给 `p2` 时，我们实际上复制了堆上的 `Point` 实例到栈上的 `p2` 变量。

### Drop trait





















