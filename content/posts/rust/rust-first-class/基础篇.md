---
title: "[Rust编程第一课]-02 基础篇"
date: 2022-12-22T11:30:00+08:00
lastmod: 2023-03-17T16:15:00+08:00
author: nange
draft: false
description: "Rust编程第一课 基础部分"

categories: ["programming"]
series: ["rust-first-class"]
series_weight: 2
tags: ["rust"]
---

## 定义变量、函数和数据结构

* ![img](/images/15e5152fe2b72794074cff40041722cb.jpg)

## 流程控制

* ![img](/images/e3a96ae58a98f46f98b56yya6378b26c.jpg)

## 模式匹配

* 假设有这样的枚举：
  ```rust
  #[derive(Debug, Copy, Clone)]
  struct UserId(u64);
  
  #[derive(Debug, Copy, Clone)]
  struct TopicId(u64);
  
  #[derive(Debug, Clone)]
  enum Event {
    Join((UserId, TopicId)),
    Leave((UserId, TopicId)),
    Message((UserId, TopicId, String)),
  }
  ```

  可以这样匹配：

  ```rust
  fn process_event(event: &Event) {
      match event {
          Event::Join((uid, tid)) => println!("user {:?} joined {:?}", uid, tid),
          Event::Leave((uid, tid)) => println!("user {:?} left {:?}", uid, tid),
          Event::Message((_, _, msg)) => println!("broadcast: {}", msg),
      }
  }
  ```

  模式匹配可以对`enum`内部数据进行匹配并赋值。

* 除了`match` 关键字外，还可以使用`if let / while let`做简单匹配，如只关心`Event::Message`：
  ```rust
  fn process_event(event: &Event) {
      if let Event::Message((_, _, msg)) = event {
          println!("broadcast: {}", msg);
      }
  }
  ```

  Rust 的模式匹配是一个很重要的语言特性，被广泛应用在状态机处理、消息处理和错误处理中。

## 错误处理

* Rust没有Java等语言中的异常处理，而是把错误封装在枚举类型中，同时提供了`?`操作符来传播错误

* `Result<T, E>`是泛型数据结构，`T`代表成功执行返回的数据类型，`E`代表错误类型

* 示例：
  ```rust
  use std::fs;
  
  fn main() {
    let url = "https://www.rust-lang.org/";
    let output = "rust.md";
    
    println!("Fetching url: {}", url);
    let body = reqwest::blocking::get(url).unwrap().text().unwrap();
  
    println!("Converting html to markdown...");
    let md = html2md::parse_html(&body);
  
    fs::write(output, md.as_bytes()).unwrap();
    println!("Converted markdown has been saved in {}.", output);
  }
  ```

  如上，如果直接调用`Result<T, E>`的`unwrap()`方法，则表示只关心成功返回的结果，如果出错，程序会`panic`终止。

  如果想让错误传播，可把`unwrap()`换成`?`操作符，并让`main`返回一个`Result`类型，如：

  ```rust
  use std::fs;
  
  fn main() -> Result<(), Box<dyn std::error::Error>> {
      let url = "https://www.rust-lang.org/";
      let output = "rust.md";
  
      println!("Fetching url: {}", url);
      let body = reqwest::blocking::get(url)?.text()?;
  
      println!("Converting html to markdown...");
      let md = html2md::parse_html(&body);
  
      fs::write(output, md.as_bytes())?;
      println!("Converted markdown has been saved in {}.", output);
  
      Ok(())
  }
  ```

* 更多关于错误处理的方式，后续再详细说明

## 项目组织

* 当代码规模很大时，需要分文件分目录来组织代码，此时就需要使用`mod`来组织代码
* 具体：在项目的入口文件`lib.rs / main.rs`里，用`mod`来声明要加载的其他代码文件。如果模块内容很多，可以在该目录下放一个`mod.rs`引入该模块的其他文件，这样就可以用`mod + 目录名`引入这个模块了。如下图所示：
  ![img](/images/8eff27daa16a2bab514590f0b567341d.jpg)

* 在Rust里，**一个项目也被称为一个crate**

  * 通过`cargo new <name> --lib` 创建一个库

  * crate代码改变时，crate需要重新编译

  * crate里，除了源代码，还可以包含单元测试和集成测试代码

  * 单元测试一般放在被测试代码相同的文件中，使用条件编译`#[cfg(test)]`确保只在测试环境下编译，如：
    ```rust
    #[cfg(test)]
    mod tests {
        #[test]
        fn it_works() {
            assert_eq!(2 + 2, 4);
        }
    }
    ```

  * 集成测试一般放在`tests`目录下，和`src`平行。集成测试只能测试`crate`下的公开接口，编译时编译成单独的可执行文件
  * 使用`cargo test`运行测试用例

* 当代码规模继续增长，把所有代码都放在同一个`crate`中不是一个好注意，因为任何代码修改都会造成`crate`重新编译，这样效率很低。**此时就需要使用Workspace。**

  * 一个Workspace可以包含一到多个crates，当代码改变时，只有涉及到的crates才需要重新编译
  * 构建一个Workspace时，需先在某个目录生成一个如下图所示的`Cargo.toml`，包含workspace里所有的crates，然后可以使用`cargo new`生成对应的crates：
  * ![img](/images/2bf542e266197e04ededc5c4a6e6cf62.jpg)
  * 更多相关细节，在后续章节补充

## 所有权

### 为什么Rust要创建所有权概念

* **变量在函数调用时发生了什么**

  ```rust 
  
  fn main() {
      let data = vec![10, 42, 9, 8];
      let v = 42;
      if let Some(pos) = find_pos(data, v) {
          println!("Found {} at {}", v, pos);
      }
  }
  
  fn find_pos(data: Vec<u32>, v: u32) -> Option<usize> {
      for (pos, item) in data.iter().enumerate() {
          if *item == v {
              return Some(pos);
          }
      }
      
      None
  }
  ```

  上面这段代码在其他大部分语言中，都是像下图所示：

  ![img](/images/f0989fa8611db83b79500060e8cd682f.jpg)

  也就是变量在栈上的部分，会被复制一份，变成另一个变量，然后指向同样的堆空间。相当于每把`data`作为参数传递一次，堆上的内存就多一次引用。

  **这样做的问题在于：** 这些引用会做什么操作，不得而知，也无从限制；堆内存什么时候能够释放，很难厘清，取决于最后一个引用什么时候结束。看似一个简单的函数调用，给内存管理带来了极大的麻烦。

  **其他大部分语言对堆内存多次引用问题的解决方案如下：**

  * C/C++ 要求开发者手动处理。这非常不便，容易出错。
  * Java等语言使用追踪式GC。通过定期扫描堆上数据还有没有人引用，来提开发者管理内存，这样方便，但是GC可能带来STW(Stop the World)问题。
  * ObjC/Swift 使用自动引用计数(ARC)。在编译时自动添加维护引用计数的代码，但这样同样有一定的运行时性能损耗。

  其他语言都是从管理引用角度思考的，都有各自的弊端。**而Rust是从限制引用行为本身角度思考的。**

### Rust的解决方案

* 一个值只能被一个变量所拥有，这个变量被称为所有者

* 一个值同一时刻只能有一个所有者。变量赋值，参数传递，函数返回等行为会把值的所有权发生转移。这就是Move语义，Rust从C++那里借鉴了这个概念。

* 当所有者离开作用域，其拥有的值被丢弃，内存得到释放

* 在Rust所有权下，上述代码的引用问题将像下面这样被解决：

  ![img](/images/fe810cf1616bce15f53bcf6d28d7f864.jpg)

  `data`被移动到`find_pos()`后，就失效了，编译器会保证随后的代码无法访问这个变量（如果出现后续继续访问的情况，编译即报错）。

* 但实际场景下，我们常常想`data`传递给`find_pos()`后，后续还想继续访问`data`，该怎么办呢？Rust提供了两种方案：

  * 除Move语义外，Rust还提供了**Copy语义**。如果一个数据结构实现了`Copy trait`，那么在赋值和传参时，值会自动按位拷贝。这样不会发生值的所有权转移。
  * 如果无法使用Copy语义，则可以使用Rust的**借用**模式。

* **Copy语义和Copy trait：**

  * 实现了Copy trait的类型，就符合Copy语义，在赋值，传参等时，值会自动按位拷贝。

  * 哪些类型实现了Copy trait呢？我们可以给自己的自定义类型实现Copy trait吗？

  * 基础类型已经实现了Copy trait，包括：

    `bool`, `char`, `i8`, `i16`..., `u8`, `u16`..., `usize`,

    `fn()` 函数也实现了Copy trait，本质可等价于一个指针

    `*const String`, `*mut String`，原始指针类型实现了Copy trait

    `&[Vec<u8>]`, `&String`, `&str`，不可变引用类型，实现了Copy trait。可变引用则没有实现Copy

    `[u8; 4]`, `(&str, &str)`，数组和元组，其值如果实现了Copy trait，那么数组和元组本身就实现了Copy trait

  * 给自定义类型实现Copy trait：

    * 可以给自定义类型添加`#[derive(Copy, Clone)]`

      这里之所以要同时派生`Clone`，是因为`Copy` 继承自`Clone`，所以类型要实现`Copy`，必须先实现`Clone`。

    * 手动实现`Copy`

      ```rust
      struct MyStruct;
      
      impl Copy for MyStruct { }
      
      impl Clone for MyStruct {
          fn clone(&self) -> MyStruct {
              *self
          }
      }
      ```

      显然通过自动派生的方式更加方便快捷。

    * 实现`Copy` 是有严格限制的，并不是所有类型都能实现`Copy`，不管是派生的方式还是手动实现都是一样的结果。要能实现`Copy`，要求类型所有成员都已经实现`Copy`。

* 除了实现`Copy`，还可以采用 **借用(Borrow)** 模式

  * Rust中引用和借用就是一个意思，通过`& 或者 &mut`来实现

  * 引用的赋值和传递不会改变值的所有权，引用实现了`Copy` trait

  * 引用在本质上是一个受控的指针：表现在**引用(借用)不能超过值的生存期**。违背了这个限制，编译将报错。而对于原始指针则没有这个限制。

  * 堆内存可以使用栈内存的引用吗？

    这是一个有迷惑性的问题。本质上是在问，这种情况下，如何保证内存安全，不会出现如悬垂引用等问题。

    ```rust
    fn main() { 
        let mut data: Vec<&u32> = Vec::new(); 
        let v = 42; 
        data.push(&v); 
        println!("data: {:?}", data);
    }
    ```

    `data`明显是放在堆上的，引用了栈上的`v`，上面的代码是OK的，因为`v`的声明周期和`data`的声明周期一样长。不会出现悬垂引用。但像下面的常见就会编译报错：

    ```rust
    fn main() {
        let mut data: Vec<&u32> = Vec::new();
        push_local_ref(&mut data);
        println!("data: {:?}", data);
    }
    
    fn push_local_ref(data: &mut Vec<&u32>) {
        let v = 42;
        data.push(&v);
    }
    ```

    **核心只需要关心调用栈的生命周期。**

  * 可变引用/借用

    * 在同一个上下文中，不能有多个可变引用。下面的代码将编译报错：

      ```rust
      fn main() {
          let mut data = vec![1, 2, 3];
      
          for item in data.iter_mut() {
              data.push(*item + 1);
          }
      }
      ```

      上面的代码是危险的，可能发送死循环等问题，好在Rust编译就不会通过。

    * 一个可变引用和若干只读引用，也是不允许的。如下面的代码将会报错：

      ```rust
      fn main() {
          let mut data = vec![1, 2, 3];
          let data1 = vec![&data[0]];
          println!("data[0]: {:p}", &data[0]);
      
          for i in 0..100 {
              data.push(i);
          }
      
          println!("data[0]: {:p}", &data[0]);
          println!("boxed: {:p}", &data1);
      }
      ```

      往`data`中push数据过程中，可能发生内存重现分配，造成`data1`中保存的`&data[0]`失效，导致内存安全问题。

    * 总结：对可变引用的限制：
      * **在一个作用域内，只允许一个活跃的可变引用**。所谓活跃，就是真正被使用来修改数据的可变引用，如果只是定义了，却没有使用或者当作只读引用使用，不算活跃。
      * 在一个作用域内，活跃的可变引用（写）和只读引用（读）是互斥的，不能同时存在。

### 所有权及引用规则的例外场景

单一所有权规则，能满足大部分场景下的内存使用需求，但凡是有例外场景，如：

* 一个有向无环图（DAG）中，某个节点可能有两个以上的节点指向它，这个按照所有权模型怎么表述？(相当于两个变量都想拿到其所有权，获得所有权这个节点才不会被回收)
* 多个线程要访问同一块共享内存，怎么办？

Rust使用引用计数的智能指针：**Rc(Reference counter) 和 Arc(Atomic reference counter)**。

#### Rc

* 使用Rc可以让某个对象有多个所有者，Rc会把对应的数据结构创建在堆上，因为堆是唯一可以让动态创建的数据被到处使用的内存。

* ```rust
  use std::rc::Rc;
  fn main() {
      let a = Rc::new(1);
      let b = a.clone();
      let c = a.clone();
  }
  ```

* 上面代码对应的内存结构如下：

  * ![img](/images/a3510f9b565577bc74bc0dcda0b3e78c.jpg)

* 三个变量共同指向堆上相同的数据，也就是说，堆上的数据有了三个共享的所有者。在这段代码结束时，c 先 drop，引用计数变成 2，然后 b drop、a drop，引用计数归零，堆上内存被释放。

* 为什么这种情况Rust编译器就不报所有权冲突的错误呢？

  * 仔细看这段代码： a 是 Rc::new(1) 的所有者，这毋庸置疑；然后 b 和 c 都调用了 a.clone()，分别得到了一个新的 Rc，所以从编译器的角度，abc 都各自拥有一个 Rc对象。因此并不违背所有权规则。

* 再看看`clone`方法的源码实现：

  * ```rust
    fn clone(&self) -> Rc<T> {
        // 增加引用计数
        self.inner().inc_strong();
        // 通过 self.ptr 生成一个新的 Rc 结构
        Self::from_inner(self.ptr)
    }
    ```

  * 内部实际上只是增加了引用计数，没有复制实际的数据。

* Rc 是怎么产生在堆上的？并且为什么这段**堆内存**不受栈内存生命周期的控制呢？即为什么`c`变量释放了，但是堆内存实际没有释放呢？是怎么实现所有的引用都释放了才释放堆内存的呢？

* **Box::leak() 机制**：

  * `Box`是Rust下的智能指针，它可以强制把任何数据结构创建在堆上，不过其生命周期仍然是受控的，跟栈上的指针一致。后面章节再详细说明。
  * `Box::leak()`，它创建的对象，从堆内存上泄露出去，不受栈内存控制，是一个自由的、生命周期可以大到和整个进程的生命周期一致的对象。
    * ![img](/images/a3510f9b565577bc74bc0dcda0b3e78c.jpg)
  * 有了 Box::leak()，就可以跳出 Rust 编译器的静态检查，保证 Rc 指向的堆内存，有最大的生命周期，然后我们再通过引用计数，在合适的时机，结束这段内存的生命周期。
  * Rust的静态检查和动态检查：
    * 静态检查，靠编译器保证代码符合所有权规则
    * 动态检查，通过 Box::leak 让堆内存拥有不受限的生命周期，然后在运行过程中，通过对引用计数的检查，保证这样的堆内存最终会得到释放

#### RefCell

* 使用Rc的引用计数机制，解决了某些场景下需要多所有权的问题，不过Rc有个问题是：**它是一个只读的引用计数器**。如果我们想修改Rc内部的数据，是无法实现的。而RefCell就能实现对内部数据的修改。

* 使用`RefCell`，可以达到：在编译器的眼里，值是只读的，但是在运行时，这个值可以得到可变借用，从而修改内部的数据。如下示例：

  * ```rust
    use std::cell::RefCell;
    
    fn main() {
        let data = RefCell::new(1);
        {
            // 获得 RefCell 内部数据的可变借用
            let mut v = data.borrow_mut();
            *v += 1;
        }
        println!("data: {:?}", data.borrow());
    }

  * `data`本身并没有申明为可变变量，但是通过`RefCell.borrow_mut`确可以修改其内部的值。
  * 之所以要把可变借用和值的修改，单独用花括号包裹起来，是因为根据所有权规则，在同一个作用域下，我们不能同时有活跃的可变借用和不可变借用。通过花括号改变了可变借用的生命周期，这样就不冲突了。
  * **如果不加花括号，将会发生运行时panic。可见所有权的借用规则在此依旧有效，只不过它在运行时检测。**

* ![img](/images/94bd27a93210ea829482663c9138de3c.jpg)

* 可以通过`Rc`包裹`RefCell`的方式，实现值有多个所有者，并且可修改内部值内部数据的能力。内存结构如下所示：

  * ![img](/images/6264d51da5c5e9025abf28d7c0dd2e46.jpg)

#### Arc 和 Mutex / RwLock

* 使用Rc和RefCell可以解决DAG的表示和更新问题，但是这只适用于单线程
* 如果需要**线程安全的引用计数器**，则需要用到**Arc**
* RefCell也不是线程安全的，在多线程中，使用内部可变性，则需要使用Mutex 或者 RwLock
  * 形如：`Rc<RefCell<T>>` -> `Arc<Mutex<T>>`



## 生命周期

* 在 Rust 中，除非显式地做 `Box::leak() / Box::into_raw() / ManualDrop` 等动作，一般来说，堆内存的生命周期，会默认和其栈内存的生命周期绑定在一起
* 在每个函数的作用域中，编译器就可以对比值和其引用的生命周期，来确保“引用的生命周期不超出值的生命周期”

### 值的生命周期

* 一个值的生命周期贯穿整个进程的生命周期，就称这种生命周期为静态生命周期
  * 当值拥有静态生命周期，其引用也具有静态生命周期。这种引用用 `'static` 来表示。比如： `&'static str` 代表这是一个具有静态生命周期的字符串引用
  * 全局变量、静态变量、字符串字面量（string literal）等，都拥有静态生命周期。上文中提到的堆内存，使用了 `Box::leak` 后，也具有静态生命周期
* 一个值是在某个作用域中定义的，也就是说它被创建在栈上或者堆上，那么其生命周期是动态的
  * 值的作用域结束时，值的生命周期也随之结束
  * 动态生命周期，约定用 `'a` 、`'b` 或者 `'hello` 这样的小写字符或者字符串来表述。 `'` 后面具体是什么名字不重要，它代表某一段动态的生命周期，其中， `&'a str` 和 `&'b str` 表示这两个字符串引用的生命周期可能不一致
  * ![img](/images/8fdc22d8ef77ecfab5d317f169a0827d.jpg)
    * 分配在堆和栈上的内存有其各自的作用域，它们的生命周期是动态的
    * 全局变量、静态变量、字符串字面量、代码等内容，在编译时，会被编译到可执行文件中的 BSS/Data/RoData/Text 段，然后在加载时，装入内存。因而，它们的生命周期和进程的生命周期一致，所以是静态的。
    * 所以，函数指针的生命周期也是静态的，因为函数在 Text 段中，只要进程活着，其内存一直存在。

### 编译器如何识别生命周期

* ```rust
  fn max(s1: &str, s2: &str) -> &str { 
      if s1 > s2 { 
          s1 
      } else { 
          s2 
      }
  }
  ```

* 上面的代码是无法通过编译的，即使实际调用的时候`s1`, `s2`以及返回值的生命周期都是正常的。原因在于`max`函数在未来会被怎么调用是不确定的，编译器只能以最坏的情况来处理，即: `s1`, `s2`的生命周期是不一致的，并且可能差距很大，因此编译器不知道返回这个引用的生命周期被后续使用会不会出问题

* 因此**函数本身携带的信息，就是编译器在编译时，使用的全部信息**

* 所以编译 max() 函数时，参数 s1 和 s2 的生命周期是什么关系、返回值和参数的生命周期又有什么关系，编译器是无法确定的，因此编译器只能报错

* 一个常见的解决方法是加上统一的生命周期标注，如下：

  ```rust
  fn max<'a>(s1: &'a str, s2: &'a str) -> &'a str { 
      if s1 > s2 { 
          s1 
      } else { 
          s2 
      }
  }
  ```

  **这样统一的标注了相同的生命周期参数，相当于是说：以最小的那个参数的生命周期为准进行检查，也就是将传入参数的最小生命周期赋给返回值参数。**

  我个人觉得Rust编译器，完全可以做的更好，如果没有标注生命周期，就将上面的这种统一标注生命周期的方式作为默认行为（因为这已经是最严格的行为），这样将大大减轻程序员负担。

### 编译器的自动标注行为

* 为了尽可能减轻开发者负担，那些明显能够编译器自动添加生命周期标注的场景，编译器将自动做

* 这些场景包括：

  * 如果只有一个引用类型输入参数，它的生命周期会赋给所有输出参数
  * 如果有多个引用类型的参数，其中一个是 self，那么它的生命周期会赋给所有输出
  * 如果有多个引用类型输入参数，它们都会各自独立的生命周期`'a`, `'b`等

* 第三条规则就是让上述没有标注生命周期函数报错的原因，因为有两个不同的生命周期标注，那返回值该标为什么呢？显然编译器无法确定，所以就报错了。但我感觉这条规则是可以考虑修改的，希望后续Rust版本能修改此规则。

* 生命周期标注目的，在参数和返回值之间建立联系或者约束。只是用来帮助编译器做生命周期检查，并不改变实际变量的生命周期

* 搞懂了函数的生命周期，可以进一步推广到结构体的生命周期标注：

  ```rust
  struct Employee<'a, 'b> {
      name: &'a str,
      title: &'b str,
      age: u8,
  }
  ```

  根据生命周期标注，上述含义是：`Employee`对象的生命周期不能超过`name`, `title`字段的任何一个，也就是要小于等于其中最小的一个。否则会对象会访问到失效的内存，当然这是不会发生的，因为有Rust编译器的生命周期检查。













