# 编写自动化测试

## 编写和运行测试
### 测试（函数）
* 测试：
  - 函数
  - 验证非测试代码的功能是否和预期一致
* 测试函数体（通常）执行3个操作：
  - 准备数据/状态
  - 运行被测试的代码
  - 断言（Assert）结果
  
### 解剖测试函数
* 测试函数需要使用test属性（attribute）进行标注
  - Attribute就是一段Rust代码的元数据
  - 在函数上加#[test],可把函数变成测试函数

### 运行测试
* 使用cargo test命令运行所有测试函数
  - Rust会构建一个Test Runner可执行文件
    * 它会运行标注了test的函数，并报告其运行是否成功

* 当使用cargo创建library项目的时候，会生成一个test module，里面有一个test函数
  - 你可以添加任意数量的test module或函数

### 测试失败
* 测试函数panic就表示失败
* 每个测试运行在一个新线程
* 当主线程看见某个测试线程挂掉了，那个测试标记为失败


## 编写测试：断言(assert)
* assert! 宏，来自标准库，用来确定某个状态是否为true
  - true：测试通过
  - false：调用panic!,测试失败

```rust
#[derive(Debug)]
pub struct Rectangle {
    length: u32,
    width: u32,
}

impl Rectangle {
    pub fn can_hold(&self, other: &Rectangle) -> bool {
        self.length > other.length && self.width > other.width
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle {
            length: 8,
            width: 7,
        };
        let smaller = Rectangle {
            length: 5,
            width: 1,
        };
        assert!(larger.can_hold(&smaller));
    }

    #[test]
    fn smaller_cannot_hold_larger() {
        let larger = Rectangle {
            length: 8,
            width: 7,
        };
        let smaller = Rectangle {
            length: 5,
            width: 1,
        };
        assert!(!smaller.can_hold(&larger));
    }

}

```

### 使用assert_eq! 和 assert_ne! 测试相等性
* 都来自标准库
* 判断两个参数是否相等或不等
* 实际上，它们使用的就是 == 和 != 运算符
* 断言失败：自动打印两个参数的值
  - 使用debug格式打印参数
    * 要求参数实现了PartialEq和Debug Traits（所有基本类型和标准库里大部分类型都实现了）

## 自定义错误消息
* 可以向assert!, assert_eq!, assert_ne! 添加可选的自定义消息
  - 这些自定义消息和失败消息都会被打印出来
  - assert!: 第1个参数必填，自定义消息作为第2个参数
  - assert_eq! 和 assert_ne!: 前2个参数必填，自定义消息作为第3个参数
  - 自定义消息参数会被传递给format!宏，可以使用{}占位符















