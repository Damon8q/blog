---
title: "[Rust编程第一课]-18 并发篇01-并发处理：从atomics到Channel，Rust都提供了什么工具？"
date: 2023-05-31T15:00:00+08:00
lastmod: 2023-06-08T12:35:00+08:00
author: nange
draft: false
description: "Rust编程第一课 并发部分"

categories: ["programming"]
series: ["rust-first-class"]
series_weight: 18
tags: ["rust"]
---

本章内容参考自：[Rust Atomics and Locks](https://marabos.nl/atomics/)

## Atomic

* 此文章只记录原子变量和锁的关键难懂的部分
* 其中一个重要的概念就是内存顺序

### memory ordering(内存顺序)

#### Reordering and Optimizations(重新排序和优化)

* 处理器和编译器会采取各种技巧，使您的程序尽可能地运行得更快。

  * 例如，处理器可能确定程序中的两个连续指令不会相互影响，并且如果这样更快，就可能乱序执行它们。
  * 但是，只有在不改变程序行为的情况下才会这样做。

* 例如：

  ```rust
  fn f(a: &mut i32, b: &mut i32) {
      *a += 1;
      *b += 1;
      *a += 1;
  }
  ```

  在这里，编译器会理解这些操作的顺序并不重要，因为在这三个加法操作之间没有任何依赖于 `*a` 或 `*b` 的值的操作。则可能会被优化为：

  ```rust
  fn f(a: &mut i32, b: &mut i32) {
      *a += 2;
      *b += 1;
  }
  ```

  **然后，在执行这个经过优化编译的程序的函数时，处理器可能因为各种原因在执行第一个加法之前，先执行第二个加法，可能是因为 `*b` 已经在缓存中可用，而 `*a` 必须从主存中获取。**

  尽管进行了这些优化，结果仍然相同： `*a` 增加了2， `*b` 增加了1。这种排序对程序的其余部分来说是完全不可见的。

* Rust 中可用的排序方式有：
  * Relaxed ordering: `Ordering::Relaxed`
  * Release and acquire ordering: `Ordering::{Release, Acquire, AcqRel}`
  * Sequentially consistent ordering: `Ordering::SeqCst`

#### The memory model(内存模型)

* **Happens-Before Relationship**

  内存模型定义了操作的发生顺序，以 happens-before 关系为基础。定义了一件事情在另一件事情之前保证发生的情况，并将其他所有事情的顺序留给未定义状态。

  * 基本的先于发生规则是：在同一线程中发生的所有事情都是有序的。如果一个线程正在执行 `f(); g();` ，那么 `f()` 就先于 `g()` 发生。

  * 然而，在线程之间，发生在之间的 happens-before 关系只在一些特定情况下发生，例如在生成和加入线程、解锁和锁定互斥锁以及通过使用非松散内存排序的原子操作。 `Relaxed` 内存排序是最基本（也是最高效的）内存排序，它本身不会导致任何跨线程的 happens-before 关系。

  * 例子，假设 `a` 和 `b` 被不同的线程同时执行：

    ```rust
    static X: AtomicI32 = AtomicI32::new(0);
    static Y: AtomicI32 = AtomicI32::new(0);
    
    fn a() {
        X.store(10, Relaxed); 1
        Y.store(20, Relaxed); 2
    }
    
    fn b() {
        let y = Y.load(Relaxed); 3
        let x = X.load(Relaxed); 4
        println!("{x} {y}");
    }
    ```

    如上所述，基本的 happens-before 规则是同一线程内发生的所有事件都是有序的。在本例中：1 先于 2 发生，3 先于 4 发生。由于我们使用松散的内存顺序，因此在上面的示例中没有其他 happens-before 的关系。
    
    因此即使输出为`0 20`，也是有可能的。

* **Spawning and Joining** 

  * 创建一个线程会在 `spawn()` 调用之前发生的事件和新线程之间建立 happens-before 关系。

  * 同样地，加入一个线程会在被加入的线程和 `join()` 调用之后发生的事件之间建立 happens-before 关系。

  * 即下面的断言不可能失败：

    ```rust
    static X: AtomicI32 = AtomicI32::new(0);
    
    fn main() {
        X.store(1, Relaxed);
        let t = thread::spawn(f);
        X.store(2, Relaxed);
        t.join().unwrap();
        X.store(3, Relaxed);
    }
    
    fn f() {
        let x = X.load(Relaxed);
        assert!(x == 1 || x == 2);
    }
    ```

    由于join和spawn操作形成的happens-before关系，我们可以确定 `X` 的加载发生在第一次存储之后，但在最后一次存储之前，如下	图所示。然而，它是在第二次存储之前还是之后观察到的值是不可预测的。换句话说，它可以加载1或2，但不能加载0或3。

    ![image-20230608123319565](/images/image-20230608123319565.png)

































