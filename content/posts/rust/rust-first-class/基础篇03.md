---
title: "[Rust编程第一课]-04 基础篇03"
date: 2023-03-23T16:30:00+08:00
lastmod: 2023-03-24T19:00:00+08:00
author: nange
draft: false
description: "Rust编程第一课 基础部分"

categories: ["programming"]
series: ["rust-first-class"]
series_weight: 4
tags: ["rust"]
---

## 类型系统

### 类型系统基本概念及分类

* 类型系统就是，对类型进行定义、检查和处理（可进行的操作和可调用的方法）的系统。完整如下图：
* ![img](/images/09ea90a4df9fb7652389f611412c1715.jpg)
  * 参数多态是指，代码操作的类型是一个满足某些约束的参数，而非具体的类型。
  * 特设多态是指同一种行为有多个不同实现的多态。比如加法，可以 1+1，也可以是 “abc” + “cde”、matrix1 + matrix2、甚至 matrix1 + vector1。在面向对象编程语言中，特设多态一般指函数的重载。
  * 子类型多态是指，在运行时，子类型可以被当成父类型使用。
  * 在 Rust 中，参数多态通过泛型来支持、特设多态通过 trait 来支持、子类型多态可以用 trait object 来支持。后续逐步学习这几种场景

### Rust类型系统

* Rust 下的内存安全：代码只能按照被允许的方法和被允许的权限，访问它被授权访问的内存。
* 为了做到严格的类型安全，Rust 中除了 `let` / `fn` / `static` / `const` 这些定义性语句外，其他都是表达式，而一切表达式都有类型。
* 对于一个作用域，无论是 `if` / `else` / `for` 循环，还是函数，最后一个表达式的返回值就是作用域的返回值，如果表达式或者函数不返回任何值，那么它返回一个 `unit()` 。`unit` 是只有一个值的类型，它的值和类型都是 `()` 。
* `unit` 的应用非常广泛，除了作为返回值，它还被大量使用在数据结构中，比如 `Result<(), Error>` 表示返回的错误类型中，我们只关心错误，不关心成功的值，再比如 `HashSet` 实际上是 `HashMap<K, ()>` 的一个类型别名。
* Rust提供了类型推导，来减轻类型标注的工作量
* 而对比动态类型系统，静态类型系统还比较麻烦的是，同一个算法，对应输入的数据结构不同，需要有不同的实现，哪怕这些实现没有什么逻辑上的差异。对此，Rust 给出的答案是泛型（参数多态）。

#### 数据类型

* Rust原生类型包括：

  ![img](/images/719040f24323c50b40724d4efb9211d0.jpg)

* 除原生类型，标准库还提供了丰富的组合类型，前面已经遇到的包括：

  ![img](/images/337088350e42836cb3372e7c5c460ec3.jpg)

* 整体框架：

  ![img](/images/44bfd66581deb983fc6eb227a6aa3afb.jpg)

#### 类型推导

* 在一个作用域之内，Rust 可以根据变量使用的上下文（可根据前后代码信息），推导出变量的类型

* 当上下文信息不足以推导出变量类型时，则需要手动标注。如：

  ```rust
  fn main() {
      let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  
      let even_numbers: Vec<_> = numbers
          .into_iter()
          .filter(|n| n % 2 == 0)
          .collect();
  
      println!("{:?}", even_numbers);
  }
  ```

  * `collect` 是 `Iterator trait` 的方法，它把一个 `iterator` 转换成一个集合。因为很多集合类型，如 `Vec`、`HashMap` 等都实现了 `Iterator`，所以这里的 `collect` 究竟要返回什么类型，编译器是无法从上下文中推断的。

  * 因此需要手动标注`even_numbers`的类型。注意这里编译器只是无法推断出集合类型，但集合类型内部元素的类型，还是可以根据上下文得出，所以我们可以简写成 `Vec<_> `。

  * 除了给变量一个显式的类型外，我们也可以让 collect 返回一个明确的类型：

    ```rust
    fn main() {
        let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    
        let even_numbers = numbers
            .into_iter()
            .filter(|n| n % 2 == 0)
            .collect::<Vec<_>>();
    
        println!("{:?}", even_numbers);
    }
    ```

    在泛型函数后使用 `::` 来强制使用类型 `T`，这种写法被称为 `turbofish`。

  * `turbofish` 的写法在很多场景都有优势，因为在某些上下文中，你想直接把一个表达式传递给一个函数或者当成一个作用域的返回值，比如：

    ```rust
    match data {
        Some(s) => v.parse::<User>()?,
        _ => return Err(...),
    }
    ```

* 有些情况下，**即使上下文中含有类型的信息，也需要开发者为变量提供类型，比如常量和静态变量的定义**：

  ```rust
  const PI: f64 = 3.1415926;
  static E: f32 = 2.71828;
  
  fn main() {
      const V: u32 = 10;
      static V1: &str = "hello";
      println!("PI: {}, E: {}, V {}, V1: {}", PI, E, V, V1);
  }
  ```

  这可能是因为 const / static 主要用于定义全局变量，它们可以在不同的上下文中使用，所以为了代码的可读性，需要明确的类型声明。

#### 泛型数据结构

TODO：

















