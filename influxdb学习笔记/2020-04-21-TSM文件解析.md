# TSM问题总结

通过回答问题的方式学习TSM文件。
TSM(Time-Structured Merge Tree)对应于LSM结构的最底层数据存储。

## tsm文件结构是怎么样的？

每个TSM文件由四个部分组成：header,blocks,index,footer：
```markdown
+--------+------------------------------------+-------------+--------------+
| Header |               Blocks               |    Index    |    Footer    |
|5 bytes |              N bytes               |   N bytes   |   4 bytes    |
+--------+------------------------------------+-------------+--------------+
```

Header部分是由一个magic number（用以标记文件类型）和一个version number组成：
```markdown
+-------------------+
|      Header       |
+-------------------+
|  Magic  │ Version |
| 4 bytes │ 1 byte  |
+-------------------+
```

Blocks是一系列连续的 CRC32 checksums 和块数据。块数据对文件是不透明的，CRC32是用于块级别的错误检测。
块长度存储在index中。
```markdown
+--------------------------------------------------------------------+
│                           Blocks                                   │
+---------------------+-----------------------+----------------------+
|       Block 1       |        Block 2        |       Block N        |
+---------------------+-----------------------+----------------------+
|   CRC    |  Data    |    CRC    |   Data    |   CRC    |   Data    |
| 4 bytes  | N bytes  |  4 bytes  | N bytes   | 4 bytes  |  N bytes  |
+---------------------+-----------------------+----------------------+
```


索引由一系列索引条目组成，这些索引条（index entries）目按key顺序排列，再按时间排序。
key包括：measurements name，tag set和一个field。
TSM文件中的每个point的多个fields会创建多个索引条目（index entries）。
每个索引条目以key长度和key开头，其后跟着是数据块类型（block type），如float，int，bool，string；
然后是索引块条目数的计数。每个索引块条目都包含此块的最小和最大时间，以及此块在文件的偏移量（offset）和块大小。

此索引结构能够提供高效的访问所有块数据，也能提供了给定一个key计算其访问代价的能力。
给定一个key和时间戳，我们就能知道一个文件是否有数据块包含了此时间戳。我们还能够知道该块所处位置以及检索此块需要读取多少数据。
知道块的大小，我们可以有效地配置IO语句。索引结构如下：
```markdown
+-----------------------------------------------------------------------------+
│                                   Index                                     │
+-----------------------------------------------------------------------------+
│ Key Len │   Key   │ Type │ Count │Min Time │Max Time │ Offset │  Size  │...│
│ 2 bytes │ N bytes │1 byte│2 bytes│ 8 bytes │ 8 bytes │8 bytes │4 bytes │   │
+-----------------------------------------------------------------------------+
```

最后一部分是footer，其存储了index的起始偏移量：
```markdown
+---------+
│ Footer  │
+---------+
│Index Ofs│
│ 8 bytes │
+---------+
```

## tsm文件压缩方式是怎样的？



## tsm文件是如何生成的？
tsm文件生成方式有两种：1. 内存cache执行snapshot(刷盘)生成。 2. 后台线程执行compaction生成。

### 从内存cache生成tsm步骤
1. 交换cache的store和snapshot，并清空store(加锁，目的是后续新的写入就写入新的store中，snapshot异步刷盘，最小化compaction对写入的影响)
2. 对snapshot内存数据做去重加排序(只是针对每个key的values数组进行去重排序，并不是全局key+时间排序)
3. 获取所有的keys(measurement + tag-set + field)，并全局排序
4. 启动后台encode线程(cpu核数个)，针对每个key生成block数据；一个key可能对应多个block(如果此key的values数量超过1000)；
   生成好的block会暂时存入内存的数组中
5. 顺序遍历key，将key的block数据顺序写入文件中(写一次block会在内存中或者磁盘上(如果预估index部分超过64MB)，维护当前block的index数据)，
   block数据写完成后，在后面添加上index的数据(索引block)，一个文件中的block最大为65535，超过会写新文件

ps：文件命名规则为：compaction次数-当次compaction生成的文件数

### 后台compaction生成tsm步骤



## tsm文件是如何读取的？







## tsm文件是如何做compaction的，和写入及读取的关系是啥？即如何防止竞态？








## tsm文件结构的优缺点是什么？

