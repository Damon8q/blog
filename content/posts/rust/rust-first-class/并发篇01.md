---
title: "[Rust编程第一课]-18 并发篇01-并发处理：从atomics到Channel，Rust都提供了什么工具？"
date: 2023-05-31T15:00:00+08:00
lastmod: 2023-06-06T19:00:00+08:00
author: nange
draft: false
description: "Rust编程第一课 并发部分"

categories: ["programming"]
series: ["rust-first-class"]
series_weight: 18
tags: ["rust"]
---

本章内容参考自：[Rust Atomics and Locks](https://marabos.nl/atomics/)

## Atomic

* 此文章只记录原子变量和锁的关键难懂的部分
* 其中一个重要的概念就是内存顺序

### memory ordering(内存顺序)

#### Reordering and Optimizations(重新排序和优化)

* 处理器和编译器会采取各种技巧，使您的程序尽可能地运行得更快。

  * 例如，处理器可能确定程序中的两个连续指令不会相互影响，并且如果这样更快，就可能乱序执行它们。
  * 但是，只有在不改变程序行为的情况下才会这样做。

* 例如：

  ```rust
  fn f(a: &mut i32, b: &mut i32) {
      *a += 1;
      *b += 1;
      *a += 1;
  }
  ```

  在这里，编译器会理解这些操作的顺序并不重要，因为在这三个加法操作之间没有任何依赖于 `*a` 或 `*b` 的值的操作。则可能会被优化为：

  ```rust
  fn f(a: &mut i32, b: &mut i32) {
      *a += 2;
      *b += 1;
  }
  ```

  **然后，在执行这个经过优化编译的程序的函数时，处理器可能因为各种原因在执行第一个加法之前，先执行第二个加法，可能是因为 `*b` 已经在缓存中可用，而 `*a` 必须从主存中获取。**

  尽管进行了这些优化，结果仍然相同： `*a` 增加了2， `*b` 增加了1。这种排序对程序的其余部分来说是完全不可见的。

* Rust 中可用的排序方式有：
  * Relaxed ordering: `Ordering::Relaxed`
  * Release and acquire ordering: `Ordering::{Release, Acquire, AcqRel}`
  * Sequentially consistent ordering: `Ordering::SeqCst`

#### The memory model(内存模型)

TODO：

































