# 基本类型

Rust每个值都有确切的类型，可以分为两类：基本类型（Primitive Type）和复合类型（Compound Type）。

基本类型意味着它们是一个最小化原子类型，无法解构为其他类型，由以下组成：

* 数值类型：有符号整数（i8, i16, i32, i64, i128, isize）、无符号整数（u8, u16, u32, u64, u128, usize）、浮点数（f32, f64）、以及有理数、复数
* 字符串： 字符串字面量 `&'static str` 和字符串切片`&str`
* 布尔类型： `true`和`false`
* 字符类型： 表示单个Unicode字符，存储为4个字节（一个u32类型整数表示）
* 单元类型：即`()`，其唯一的值也是`()`



# 类型推导与标注

大部分时候，我们不需要为变量指定类型，Rust编译器很聪明，它可以根据变量的值和上下文的使用方式来自动推导出变量的类型。 

但自动类型推导也不是万能的，在某些情况下，其也无法推导出变量类型，此时就需要手动添加类型标注。如下面代码：

```rust
let guess = "42".parse().expect("Not a number!");
```

此时编译器就会报错，因为其无法推导出我们想要的类型是：整数？浮点数？字符串？

需要改为：

```rust
let guess: i32 = ... 或者 "42".parse::<i32>()
```



# 数值类型

## 整数和浮点数

整数和浮点数的运算是通过运算符来完成。不仅仅整数，Rust也允许在复杂类型上定义运算符，例如在自定义类型上定义`+`运算符，这种行为被称为运算符重载。



### 整数类型

| 长度       | 有符号类型 | 无符号类型 |
| ---------- | ---------- | ---------- |
| 8 位       | `i8`       | `u8`       |
| 16 位      | `i16`      | `u16`      |
| 32 位      | `i32`      | `u32`      |
| 64 位      | `i64`      | `u64`      |
| 128-位     | `i128`     | `u128`     |
| 视架构而定 | `isize`    | `usize`    |



**整形字面量可以用下表的形式书写：**

| 数字字面量         | 示例          |
| ------------------ | ------------- |
| 十进制             | `98_222`      |
| 十六进制           | `0xff`        |
| 八进制             | `0o77`        |
| 二进制             | `0b1111_0000` |
| 字节 (仅限于 `u8`) | `b'A'`        |

Rust的整形默认使用`i32`，例如`let i = 1	`，那么`i`就是`i32`类型，同时该类型也往往是性能最好的。`isize`和`usize`的主要应用场景是用作集合的索引。



> **整形溢出**
>
> 要显式处理可能的溢出，可以使用标准库针对原始数字类型提供的这些方法：
>
> - 使用 `wrapping_*` 方法在所有模式下都按照补码循环溢出规则处理，例如 `wrapping_add`
> - 如果使用 `checked_*` 方法时发生溢出，则返回 `None` 值
> - 使用 `overflowing_*` 方法返回该值和一个指示是否存在溢出的布尔值
> - 使用 `saturating_*` 方法使值达到最小值或最大值
>
> 例如：
>
> ```rust
> let a: i32 = 128;
> let b = a.wrapping_add(100);
> ```



### 浮点类型

Rust中浮点类型包含两种类型：f32和f64。默认浮点类型是f64，在现代CPU中它速度和f32几乎相同，但精度更高。

示例：

```rust
fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
```

浮点数根据 `IEEE-754` 标准实现。`f32` 类型是单精度浮点型，`f64` 为双精度。



### 浮点数陷阱

* 浮点数往往是你想要数字的近似表达。 例如 `0.1` 在二进制上并不存在精确的表达形式，但是在十进制上就存在。
* 浮点数在某些特性上是反直觉的。`f32` ， `f64` 上的比较运算实现的是 `std::cmp::PartialEq` 特征(类似其他语言的接口)，但是并没有实现 `std::cmp::Eq` 特征。这就造成浮点数无法作为HashMap的K，因为HashMap要求其K必须实现`std::cmp::Eq`。
* 为了避免上面两个陷阱，需要遵守以下准则：
  - 避免在浮点数上测试相等性
  - 当结果在数学上可能存在未定义时，需要格外小心

那如果非要进行比较呢？可以考虑用这种方式 `(0.1 + 0.2 - 0.3).abs() < 0.00001` ，具体小于多少，取决于你对精度的需求。

下面看一段震撼灵魂的代码：

```rust
fn main() {
    let abc: (f32, f32, f32) = (0.1, 0.2, 0.3);
    let xyz: (f64, f64, f64) = (0.1, 0.2, 0.3);

    println!("abc (f32)");
    println!("   0.1 + 0.2: {:x}", (abc.0 + abc.1).to_bits());
    println!("         0.3: {:x}", (abc.2).to_bits());
    println!();

    println!("xyz (f64)");
    println!("   0.1 + 0.2: {:x}", (xyz.0 + xyz.1).to_bits());
    println!("         0.3: {:x}", (xyz.2).to_bits());
    println!();

    assert!(abc.0 + abc.1 == abc.2);
    assert!(xyz.0 + xyz.1 == xyz.2);
}
```

运行该程序，输出如下:

```tex
abc (f32)
   0.1 + 0.2: 3e99999a
         0.3: 3e99999a
 
xyz (f64)
   0.1 + 0.2: 3fd3333333333334
         0.3: 3fd3333333333333
 
thread 'main' panicked at 'assertion failed: xyz.0 + xyz.1 == xyz.2',
➥ch2-add-floats.rs.rs:14:5
note: run with `RUST_BACKTRACE=1` environment variable to display
➥a backtrace
```

仔细看，对 `f32` 类型做加法时，`0.1 + 0.2` 的结果是 `3e99999a`，`0.3` 也是 `3e99999a`，因此 `f32` 下的 `0.1 + 0.2 == 0.3` 通过测试，但是到了 `f64` 类型时，结果就不一样了，因为 `f64` 精度高很多，因此在小数点非常后面发生了一点微小的变化，`0.1 + 0.2` 以 `4` 结尾，但是 `0.3` 以`3`结尾，这个细微区别导致 `f64` 下的测试失败了，并且抛出了异常。



### NaN

对于数学上未定义的结果，例如对负数取平方根 `-42.1.sqrt()` ，会产生一个特殊的结果：Rust 的浮点数类型使用 `NaN` (not a number)来处理这些情况。

**所有跟 `NaN` 交互的操作，都会返回一个 `NaN`**，而且 `NaN` 不能用来比较，下面的代码会崩溃：

```rust
fn main() {
  let x = (-42.0_f32).sqrt();
  assert_eq!(x, x);
}
```

出于防御性编程的考虑，可以使用 `is_nan()` 等方法，可以用来判断一个数值是否是 `NaN` ：

```rust
fn main() {
    let x = (-42.0_f32).sqrt();
    if x.is_nan() {
        println!("未定义的数学行为")
    }
}
```



### 序列（Range）

Rust提供了一种非常简洁的方式，来生成连续的数值，例如`1..5`，生成从1到4的连续数字，不包含5；`1..=5`，生成从1到5的连续数字，包含5，此用途很简单，常常用在循环中：

```rust
for i in 1..=5 {
    println!("{}",i);
}
```

最终程序输出:

```tex
1
2
3
4
5
```



序列只允许用于数字或字符类型，如下是一个使用字符类型序列的例子：

```rust
for i in 'a'..='z' {
    println!("{}", i);
}
```



### 有理数和复数

Rust 的标准库相比其它语言，对于准入的门槛较高，因此有理数和复数并未包含在标准库中：

- 有理数和复数
- 任意大小的整数和任意精度的浮点数
- 固定精度的十进制小数，常用于货币相关的场景

好在社区已经开发出高质量的 Rust 数值库：[num](https://crates.io/crates/num)。

基于num库，使用复数的示例：

```rust
use num::complex::Complex;

fn main() {
    let a = Complex { re: 2.1, im: -1.2 };
    let b = Complex::new(11.1, 22.2);
    let result = a + b;

    println!("{} + {}i", result.re, result.im)
}

```



## 总结

* Rust有相当多的数值类型。
* 类型转换必须是显示的。Rust永远不会偷偷的把你的16bit整数转换为32bit整数。
* Rust数值上可以使用方法。例如你可以使用下面方法来将13.14取整：`13.14_f32.round()`，在这里我们使用了类型后缀，因为编译器需要知道 `13.14 `的具体类型



# 字符、布尔、单元类型

## 字符类型（char）

```rust
fn main() {
    let c = 'z';
    let z = 'ℤ';
    let g = '国';
    let heart_eyed_cat = '😻';
    println!("字符'z'占用了{}字节的内存大小",std::mem::size_of_val(&c));	// 4
    println!("字符'ℤ'占用了{}字节的内存大小",std::mem::size_of_val(&z));	// 4
    println!("字符'国'占用了{}字节的内存大小",std::mem::size_of_val(&g));	// 4
    println!("字符'😻'占用了{}字节的内存大小",std::mem::size_of_val(&heart_eyed_cat));	// 4
}
```

一个`Unicode`值即是一个字符（char），由于 `Unicode` 都是 4 个字节编码，因此字符类型也是占用 4 个字节。

> 注意：Rust字符只能用`''`来表示，`""`是留给字符串的



## 布尔（bool）

Rust 中的布尔类型有两个可能的值：`true` 和 `false`, 布尔值占用内存的大小为 `1` 个字节。使用布尔类型的场景主要在于流程控制。



## 单元类型

单元类型就是`()`，唯一的值也是`()`。

前面多次看到的， `main` 函数就返回这个单元类型 `()`，你不能说 `main` 函数无返回值，因为没有返回值的函数在 Rust 中是有单独的定义的：`发散函数`，顾名思义，无法收敛的函数。

例如常见的 `println!()` 的返回值也是单元类型 `()`。

再比如，你可以用 `()` 作为 `map` 的值，表示我们不关注具体的值，只关注 `key`。 这种用法和 Go 语言的 ***struct{}*** 类似，可以作为一个值用来占位，但是完全**不占用**任何内存。



# 语句和表达式

Rust 的函数体是由一系列语句组成，最后由一个表达式来返回值，例如：

```rust
fn add_with_extra(x: i32, y: i32) -> i32 {
    let x = x + 1; // 语句
    let y = y + 5; // 语句
    x + y // 表达式
}
```

语句会执行一些操作但是不会返回一个值，而表达式会在求值后返回一个值，因此在上述函数体的三行代码中，前两行是语句，最后一行是表达式。

**这种基于语句和表达式的方式是非常重要的，你需要能明确的区分这两个概念**。基于表达式是函数式语言的重要特征，**表达式总要返回值**。



## 语句

```rust
let a = 8;
let b: Vec<f64> = Vec::new();
let (a, c) = ("hi", false);
```

以上都是语句，它们完成了一个具体的操作，但是并没有返回值，因此是语句。

由于 `let` 是语句，因此不能将 `let` 语句赋值给其它值，如下形式是错误的：

```rust
let b = (let a = 8);
```

错误如下：

```tex
error: expected expression, found statement (`let`) // 期望表达式，却发现`let`语句
 --> src/main.rs:2:13
  |
2 |     let b = let a = 8;
  |             ^^^^^^^^^
  |
  = note: variable declaration using `let` is a statement `let`是一条语句

error[E0658]: `let` expressions in this position are experimental
          // 下面的 `let` 用法目前是试验性的，在稳定版中尚不能使用
 --> src/main.rs:2:13
  |
2 |     let b = let a = 8;
  |             ^^^^^^^^^
  |
  = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information
  = help: you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`

```

以上的错误告诉我们 `let` 是语句，不是表达式，因此它不返回值，也就不能给其它变量赋值。但是该错误还透漏了一个重要的信息， `let` 作为表达式已经是试验功能了，也许不久的将来，我们在[`stable rust`](https://course.rs/appendix/rust-version.html)下可以这样使用。



## 表达式

表达式会进行求值，然后返回一个值。例如 `5 + 6`，在求值后，返回值 `11`，因此它就是一条表达式。

表达式可以成为语句的一部分，例如`let y = 6`中，6就是一个表达式，用花括号包裹最终返回一个值的语句块也是表达式，总之，能返回值，它就是表达式：

```rust
fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!("The value of y is: {}", y);
}
```

上面使用一个语句块表达式将值赋给 `y` 变量。

该语句块是表达式的原因是：它的最后一行是表达式，返回了 `x + 1` 的值，注意 `x + 1` 不能以分号结尾，否则就会从表达式变成语句， **表达式不能包含分号**。



# 函数

一个简单但有完备的函数：

```rust
fn add(i: i32, j: i32) -> i32 {
   i + j
 }
```

函数的构成：

![img](/home/nange/go/src/github.com/nange/blog/rust-notes/rust-course/basic-of-rust/image/function-01.png)



## 函数要点

* 函数名和变量名使用蛇形命名法（snake case），例如`fn add_two() -> {}`
* 函数的位置可以随便放，Rust 不关心我们在哪里定义了函数，只要有定义即可
* 每个函数参数都需要标注类型



## 函数返回

在 Rust 中函数就是表达式，因此我们可以把函数的返回值直接赋给调用者。

函数的返回值就是函数体最后一条表达式的返回值，当然我们也可以使用 `return` 提前返回，如下：

```rust
fn plus_or_substract(x:i32) -> i32 {
    if x > 5 {
        return x - 5
    }

    x + 5
}

fn main() {
    let x = plus_or_substract(5);

    println!("The value of x is: {}", x);
}
```



### Rust中特殊返回类型

* **无返回值`()`**
  单元类型 `()`，是一个零长度的元组。它没啥作用，但是可以用来表达一个函数没有返回值（实际上是隐式返回了`()`，等价于显示返回`()`）：
  - 函数没有返回值，那么返回一个`()`
  - 通过`;`结尾的表达式返回一个`()`

* **永不返回的函数!**
  感叹号，当用作函数返回值的时候，表示该函数永不返回，特别的，这种语法往往用做会导致程序崩溃的函数：

  ```rust
  fn dead_end() -> ! {
    panic!("你已经到了穷途末路，崩溃吧！");
  }
  ```

  下面的函数创建了一个无限循环，该循环永不跳出，因此函数也永不返回：

  ```rust
  fn forever() -> ! {
    loop {
      //...
    };
  }
  ```

