---
title: "[Rust编程第一课]-03 基础篇02"
date: 2023-03-18T17:30:00+08:00
lastmod: 2023-03-18T17:45:00+08:00
author: nange
draft: false
description: "Rust编程第一课 基础部分"

categories: ["programming"]
series: ["rust-first-class"]
series_weight: 3
tags: ["rust"]
---



## 所有权

### 为什么Rust要创建所有权概念

* **变量在函数调用时发生了什么**

  ```rust 
  fn main() {
      let data = vec![10, 42, 9, 8];
      let v = 42;
      if let Some(pos) = find_pos(data, v) {
          println!("Found {} at {}", v, pos);
      }
  }
  
  fn find_pos(data: Vec<u32>, v: u32) -> Option<usize> {
      for (pos, item) in data.iter().enumerate() {
          if *item == v {
              return Some(pos);
          }
      }
      
      None
  }
  ```

  上面这段代码在其他大部分语言中，都是像下图所示：

  ![img](/images/f0989fa8611db83b79500060e8cd682f.jpg)

  也就是变量在栈上的部分，会被复制一份，变成另一个变量，然后指向同样的堆空间。相当于每把`data`作为参数传递一次，堆上的内存就多一次引用。

  **这样做的问题在于：** 这些引用会做什么操作，不得而知，也无从限制；堆内存什么时候能够释放，很难厘清，取决于最后一个引用什么时候结束。看似一个简单的函数调用，给内存管理带来了极大的麻烦。

  **其他大部分语言对堆内存多次引用问题的解决方案如下：**

  * C/C++ 要求开发者手动处理。这非常不便，容易出错。
  * Java等语言使用追踪式GC。通过定期扫描堆上数据还有没有人引用，来提开发者管理内存，这样方便，但是GC可能带来STW(Stop the World)问题。
  * ObjC/Swift 使用自动引用计数(ARC)。在编译时自动添加维护引用计数的代码，但这样同样有一定的运行时性能损耗。

  其他语言都是从管理引用角度思考的，都有各自的弊端。**而Rust是从限制引用行为本身角度思考的。**

### Rust的解决方案

* 一个值只能被一个变量所拥有，这个变量被称为所有者

* 一个值同一时刻只能有一个所有者。变量赋值，参数传递，函数返回等行为会把值的所有权发生转移。这就是Move语义，Rust从C++那里借鉴了这个概念。

* 当所有者离开作用域，其拥有的值被丢弃，内存得到释放

* 在Rust所有权下，上述代码的引用问题将像下面这样被解决：

  ![img](/images/fe810cf1616bce15f53bcf6d28d7f864.jpg)

  `data`被移动到`find_pos()`后，就失效了，编译器会保证随后的代码无法访问这个变量（如果出现后续继续访问的情况，编译即报错）。

* 但实际场景下，我们常常想`data`传递给`find_pos()`后，后续还想继续访问`data`，该怎么办呢？Rust提供了两种方案：

  * 除Move语义外，Rust还提供了**Copy语义**。如果一个数据结构实现了`Copy trait`，那么在赋值和传参时，值会自动按位拷贝。这样不会发生值的所有权转移。
  * 如果无法使用Copy语义，则可以使用Rust的**借用**模式。

* **Copy语义和Copy trait：**

  * 实现了Copy trait的类型，就符合Copy语义，在赋值，传参等时，值会自动按位拷贝。

  * 哪些类型实现了Copy trait呢？我们可以给自己的自定义类型实现Copy trait吗？

  * 基础类型已经实现了Copy trait，包括：

    `bool`, `char`, `i8`, `i16`..., `u8`, `u16`..., `usize`,

    `fn()` 函数也实现了Copy trait，本质可等价于一个指针

    `*const String`, `*mut String`，原始指针类型实现了Copy trait

    `&[Vec<u8>]`, `&String`, `&str`，不可变引用类型，实现了Copy trait。可变引用则没有实现Copy

    `[u8; 4]`, `(&str, &str)`，数组和元组，其值如果实现了Copy trait，那么数组和元组本身就实现了Copy trait

  * 给自定义类型实现Copy trait：

    * 可以给自定义类型添加`#[derive(Copy, Clone)]`

      这里之所以要同时派生`Clone`，是因为`Copy` 继承自`Clone`，所以类型要实现`Copy`，必须先实现`Clone`。

    * 手动实现`Copy`

      ```rust
      struct MyStruct;
      
      impl Copy for MyStruct { }
      
      impl Clone for MyStruct {
          fn clone(&self) -> MyStruct {
              *self
          }
      }
      ```

      显然通过自动派生的方式更加方便快捷。

    * 实现`Copy` 是有严格限制的，并不是所有类型都能实现`Copy`，不管是派生的方式还是手动实现都是一样的结果。要能实现`Copy`，要求类型所有成员都已经实现`Copy`。

* 除了实现`Copy`，还可以采用 **借用(Borrow)** 模式

  * Rust中引用和借用就是一个意思，通过`& 或者 &mut`来实现

  * 引用的赋值和传递不会改变值的所有权，引用实现了`Copy` trait

  * 引用在本质上是一个受控的指针：表现在**引用(借用)不能超过值的生存期**。违背了这个限制，编译将报错。而对于原始指针则没有这个限制。

  * 堆内存可以使用栈内存的引用吗？

    这是一个有迷惑性的问题。本质上是在问，这种情况下，如何保证内存安全，不会出现如悬垂引用等问题。

    ```rust
    fn main() { 
        let mut data: Vec<&u32> = Vec::new(); 
        let v = 42; 
        data.push(&v); 
        println!("data: {:?}", data);
    }
    ```

    `data`明显是放在堆上的，引用了栈上的`v`，上面的代码是OK的，因为`v`的声明周期和`data`的声明周期一样长。不会出现悬垂引用。但像下面的常见就会编译报错：

    ```rust
    fn main() {
        let mut data: Vec<&u32> = Vec::new();
        push_local_ref(&mut data);
        println!("data: {:?}", data);
    }
    
    fn push_local_ref(data: &mut Vec<&u32>) {
        let v = 42;
        data.push(&v);
    }
    ```

    **核心只需要关心调用栈的生命周期。**

  * 可变引用/借用

    * 在同一个上下文中，不能有多个可变引用。下面的代码将编译报错：

      ```rust
      fn main() {
          let mut data = vec![1, 2, 3];
      
          for item in data.iter_mut() {
              data.push(*item + 1);
          }
      }
      ```

      上面的代码是危险的，可能发送死循环等问题，好在Rust编译就不会通过。

    * 一个可变引用和若干只读引用，也是不允许的。如下面的代码将会报错：

      ```rust
      fn main() {
          let mut data = vec![1, 2, 3];
          let data1 = vec![&data[0]];
          println!("data[0]: {:p}", &data[0]);
      
          for i in 0..100 {
              data.push(i);
          }
      
          println!("data[0]: {:p}", &data[0]);
          println!("boxed: {:p}", &data1);
      }
      ```

      往`data`中push数据过程中，可能发生内存重现分配，造成`data1`中保存的`&data[0]`失效，导致内存安全问题。

    * 总结：对可变引用的限制：

      * **在一个作用域内，只允许一个活跃的可变引用**。所谓活跃，就是真正被使用来修改数据的可变引用，如果只是定义了，却没有使用或者当作只读引用使用，不算活跃。
      * 在一个作用域内，活跃的可变引用（写）和只读引用（读）是互斥的，不能同时存在。

### 所有权及引用规则的例外场景

单一所有权规则，能满足大部分场景下的内存使用需求，但凡是有例外场景，如：

* 一个有向无环图（DAG）中，某个节点可能有两个以上的节点指向它，这个按照所有权模型怎么表述？(相当于两个变量都想拿到其所有权，获得所有权这个节点才不会被回收)
* 多个线程要访问同一块共享内存，怎么办？

Rust使用引用计数的智能指针：**Rc(Reference counter) 和 Arc(Atomic reference counter)**。

#### Rc

* 使用Rc可以让某个对象有多个所有者，Rc会把对应的数据结构创建在堆上，因为堆是唯一可以让动态创建的数据被到处使用的内存。

* ```rust
  use std::rc::Rc;
  fn main() {
      let a = Rc::new(1);
      let b = a.clone();
      let c = a.clone();
  }
  ```

* 上面代码对应的内存结构如下：

  * ![img](/images/a3510f9b565577bc74bc0dcda0b3e78c.jpg)

* 三个变量共同指向堆上相同的数据，也就是说，堆上的数据有了三个共享的所有者。在这段代码结束时，c 先 drop，引用计数变成 2，然后 b drop、a drop，引用计数归零，堆上内存被释放。

* 为什么这种情况Rust编译器就不报所有权冲突的错误呢？

  * 仔细看这段代码： a 是 Rc::new(1) 的所有者，这毋庸置疑；然后 b 和 c 都调用了 a.clone()，分别得到了一个新的 Rc，所以从编译器的角度，abc 都各自拥有一个 Rc对象。因此并不违背所有权规则。

* 再看看`clone`方法的源码实现：

  * ```rust
    fn clone(&self) -> Rc<T> {
        // 增加引用计数
        self.inner().inc_strong();
        // 通过 self.ptr 生成一个新的 Rc 结构
        Self::from_inner(self.ptr)
    }
    ```

  * 内部实际上只是增加了引用计数，没有复制实际的数据。

* Rc 是怎么产生在堆上的？并且为什么这段**堆内存**不受栈内存生命周期的控制呢？即为什么`c`变量释放了，但是堆内存实际没有释放呢？是怎么实现所有的引用都释放了才释放堆内存的呢？

* **Box::leak() 机制**：

  * `Box`是Rust下的智能指针，它可以强制把任何数据结构创建在堆上，不过其生命周期仍然是受控的，跟栈上的指针一致。后面章节再详细说明。
  * `Box::leak()`，它创建的对象，从堆内存上泄露出去，不受栈内存控制，是一个自由的、生命周期可以大到和整个进程的生命周期一致的对象。
    * ![img](/images/a3510f9b565577bc74bc0dcda0b3e78c.jpg)
  * 有了 Box::leak()，就可以跳出 Rust 编译器的静态检查，保证 Rc 指向的堆内存，有最大的生命周期，然后我们再通过引用计数，在合适的时机，结束这段内存的生命周期。
  * Rust的静态检查和动态检查：
    * 静态检查，靠编译器保证代码符合所有权规则
    * 动态检查，通过 Box::leak 让堆内存拥有不受限的生命周期，然后在运行过程中，通过对引用计数的检查，保证这样的堆内存最终会得到释放

#### RefCell

* 使用Rc的引用计数机制，解决了某些场景下需要多所有权的问题，不过Rc有个问题是：**它是一个只读的引用计数器**。如果我们想修改Rc内部的数据，是无法实现的。而RefCell就能实现对内部数据的修改。

* 使用`RefCell`，可以达到：在编译器的眼里，值是只读的，但是在运行时，这个值可以得到可变借用，从而修改内部的数据。如下示例：

  * ```rust
    use std::cell::RefCell;
    
    fn main() {
        let data = RefCell::new(1);
        {
            // 获得 RefCell 内部数据的可变借用
            let mut v = data.borrow_mut();
            *v += 1;
        }
        println!("data: {:?}", data.borrow());
    }
    ```

  * `data`本身并没有申明为可变变量，但是通过`RefCell.borrow_mut`确可以修改其内部的值。

  * 之所以要把可变借用和值的修改，单独用花括号包裹起来，是因为根据所有权规则，在同一个作用域下，我们不能同时有活跃的可变借用和不可变借用。通过花括号改变了可变借用的生命周期，这样就不冲突了。

  * **如果不加花括号，将会发生运行时panic。可见所有权的借用规则在此依旧有效，只不过它在运行时检测。**

* ![img](/images/94bd27a93210ea829482663c9138de3c.jpg)

* 可以通过`Rc`包裹`RefCell`的方式，实现值有多个所有者，并且可修改内部值内部数据的能力。内存结构如下所示：

  * ![img](/images/6264d51da5c5e9025abf28d7c0dd2e46.jpg)

#### Arc 和 Mutex / RwLock

* 使用Rc和RefCell可以解决DAG的表示和更新问题，但是这只适用于单线程
* 如果需要**线程安全的引用计数器**，则需要用到**Arc**
* RefCell也不是线程安全的，在多线程中，使用内部可变性，则需要使用Mutex 或者 RwLock
  * 形如：`Rc<RefCell<T>>` -> `Arc<Mutex<T>>`



## 生命周期

* 在 Rust 中，除非显式地做 `Box::leak() / Box::into_raw() / ManualDrop` 等动作，一般来说，堆内存的生命周期，会默认和其栈内存的生命周期绑定在一起
* 在每个函数的作用域中，编译器就可以对比值和其引用的生命周期，来确保“引用的生命周期不超出值的生命周期”

### 值的生命周期

* 一个值的生命周期贯穿整个进程的生命周期，就称这种生命周期为静态生命周期
  * 当值拥有静态生命周期，其引用也具有静态生命周期。这种引用用 `'static` 来表示。比如： `&'static str` 代表这是一个具有静态生命周期的字符串引用
  * 全局变量、静态变量、字符串字面量（string literal）等，都拥有静态生命周期。上文中提到的堆内存，使用了 `Box::leak` 后，也具有静态生命周期
* 一个值是在某个作用域中定义的，也就是说它被创建在栈上或者堆上，那么其生命周期是动态的
  * 值的作用域结束时，值的生命周期也随之结束
  * 动态生命周期，约定用 `'a` 、`'b` 或者 `'hello` 这样的小写字符或者字符串来表述。 `'` 后面具体是什么名字不重要，它代表某一段动态的生命周期，其中， `&'a str` 和 `&'b str` 表示这两个字符串引用的生命周期可能不一致
  * ![img](/images/8fdc22d8ef77ecfab5d317f169a0827d.jpg)
    * 分配在堆和栈上的内存有其各自的作用域，它们的生命周期是动态的
    * 全局变量、静态变量、字符串字面量、代码等内容，在编译时，会被编译到可执行文件中的 BSS/Data/RoData/Text 段，然后在加载时，装入内存。因而，它们的生命周期和进程的生命周期一致，所以是静态的。
    * 所以，函数指针的生命周期也是静态的，因为函数在 Text 段中，只要进程活着，其内存一直存在。

### 编译器如何识别生命周期

* ```rust
  fn max(s1: &str, s2: &str) -> &str { 
      if s1 > s2 { 
          s1 
      } else { 
          s2 
      }
  }
  ```

* 上面的代码是无法通过编译的，即使实际调用的时候`s1`, `s2`以及返回值的生命周期都是正常的。原因在于`max`函数在未来会被怎么调用是不确定的，编译器只能以最坏的情况来处理，即: `s1`, `s2`的生命周期是不一致的，并且可能差距很大，因此编译器不知道返回这个引用的生命周期被后续使用会不会出问题

* 因此**函数本身携带的信息，就是编译器在编译时，使用的全部信息**

* 所以编译 max() 函数时，参数 s1 和 s2 的生命周期是什么关系、返回值和参数的生命周期又有什么关系，编译器是无法确定的，因此编译器只能报错

* 一个常见的解决方法是加上统一的生命周期标注，如下：

  ```rust
  fn max<'a>(s1: &'a str, s2: &'a str) -> &'a str { 
      if s1 > s2 { 
          s1 
      } else { 
          s2 
      }
  }
  ```

  **这样统一的标注了相同的生命周期参数，相当于是说：以最小的那个参数的生命周期为准进行检查，也就是将传入参数的最小生命周期赋给返回值参数。**

  我个人觉得Rust编译器，完全可以做的更好，如果没有标注生命周期，就将上面的这种统一标注生命周期的方式作为默认行为（因为这已经是最严格的行为），这样将大大减轻程序员负担。

### 编译器的自动标注行为

* 为了尽可能减轻开发者负担，那些明显能够编译器自动添加生命周期标注的场景，编译器将自动做

* 这些场景包括：

  * 如果只有一个引用类型输入参数，它的生命周期会赋给所有输出参数
  * 如果有多个引用类型的参数，其中一个是 self，那么它的生命周期会赋给所有输出
  * 如果有多个引用类型输入参数，它们都会各自独立的生命周期`'a`, `'b`等

* 第三条规则就是让上述没有标注生命周期函数报错的原因，因为有两个不同的生命周期标注，那返回值该标为什么呢？显然编译器无法确定，所以就报错了。但我感觉这条规则是可以考虑修改的，希望后续Rust版本能修改此规则。

* 生命周期标注目的，在参数和返回值之间建立联系或者约束。只是用来帮助编译器做生命周期检查，并不改变实际变量的生命周期

* 搞懂了函数的生命周期，可以进一步推广到结构体的生命周期标注：

  ```rust
  struct Employee<'a, 'b> {
      name: &'a str,
      title: &'b str,
      age: u8,
  }
  ```

  根据生命周期标注，上述含义是：`Employee`对象的生命周期不能超过`name`, `title`字段的任何一个，也就是要小于等于其中最小的一个。否则会对象会访问到失效的内存，当然这是不会发生的，因为有Rust编译器的生命周期检查。

## 内存管理：值在内存中的一生

* 理论上，编译时可以确定大小的值都会放在栈上。如字符、数组、元组(tuple)等，以及自定义但是固定大小的结构体(struct)、枚举(enum)等

* 数据大小无法确定，或者大小确定但是使用时需要更长的生命周期，都应放在堆上

* 几种重要数据结构的内存布局：

  * **struct** 

    * C语言对结构体字段对其的处理：
      * 确定每个字段的长度和对齐长度，类型的对齐长度和类型的长度一致
      * 每个字段的起始位置要和其对齐长度对齐，如果无法对齐，则添加 padding 直至对齐
      * 结构体的对齐大小和其最大字段的对齐大小相同，而结构体的长度则四舍五入到其对齐的倍数

    * Rust 在内存中排布数据时，会根据每个域的对齐（aligment）对数据进行重排，使其内存大小和访问效率最好。因为 CPU 在加载不对齐的内存时，性能会急剧下降，所以要避免用户定义不对齐的数据结构时，造成的性能影响。

    * Rust和C语言对比：

      ![img](/images/3db1a2ccebf936aa10d9c1bd7fcf8a42.jpg)

      虽然，Rust 编译器默认为开发者优化结构体的排列，但你也可以使用#[repr] 宏，强制让 Rust 编译器不做优化，和 C 的行为一致，这样，Rust 代码可以方便地和 C 代码无缝交互。

  * **tuple**

    拥有和`struct`类型的行为

  * **enum**

    * `enum`本质上是一个标签联合体(类似于C语言中的`union`类型)。它是由不同的数据类型组成的数据结构，但只能同时包含其中一个数据类型的值。标签联合体类型通常由一个标签和一个具体的值组成。标签指示了当前使用的值的数据类型，以便程序可以正确地解释该值。当程序访问标签联合体类型的值时，程序必须先读取标签，然后才能使用正确的数据类型来解释该值。

    * 因此它的大小是标签的大小，加上最大类型的长度(对齐第三条规则)

    * 两种简单常见枚举举例：Option 和 Result， Option 是有值 / 无值这种最简单的枚举类型，Result 包括成功返回数据和错误返回数据的枚举类型

      * 根据三条对齐规则，tag 后的内存，会根据其对齐大小进行对齐，所以对于 `Option<u8>`，其长度是 1 + 1 = 2 字节，而 `Option<f64>`，长度是 8 + 8 =16 字节。一般而言，64 位 CPU 下，enum 的最大长度是：最大类型的长度 + 8，因为 64 位 CPU 的最大对齐是 64bit，也就是 8 个字节

      * 下图展示了 enum、Option 以及 Result 的布局：

        ![img](/images/f22b2700de556385efbc44f04dd6b982.jpg)

    * Rust对`enum`的一些额外优化，使得某些结构内存更紧凑：

      * ```rust
        enum E { 
            A(f64), 
            B(HashMap), 
            C(Result, String>),
        }
        fn main() { 
            show_size!(header); 
            show_size!(u8); 
            show_size!(f64); 
            show_size!(&u8); 
            show_size!(Box); 
            show_size!(&[u8]); 
            show_size!(String); 
            show_size!(Vec); 
            show_size!(HashMap); 
            show_size!(E);
        }
        ```

      * 我们发现`Option` 配合带有引用类型的数据结构，比如 `&u8`、`Box`、`Vec`、`HashMap` ，没有额外占用空间，这是怎么做到的呢？

      * 正常来说，当我们把它和一个引用放在一起时，虽然 tag 只占 1 个 bit，但 64 位 CPU 下，引用结构的对齐是 8，所以它自己加上额外的 padding，会占据 8 个字节，一共 16 字节，这非常浪费内存。怎么办呢？

      * 引用类型的第一个域是个指针，而指针是不可能等于 0 的，但是我们**可以复用这个指针：当其为 0 时，表示 None，否则是 Some**，减少了内存占用，这是个非常巧妙的优化，我们可以学习。

  * **vec<T> 和 String**

    * 从刚才代码的结果中，看到 `String` 和 `Vec` 占用相同的大小，都是 24 个字节。从Rust源码角度看`String`的内部就是一个`Vec<u8>`

    * `Vec<T>`结构是3个word的胖指针，包含：一个指向堆内存的指针pointer、分配的堆内存的容量capacity，以及数据在堆内存的长度length，如下图：

      ![img](/images/c2234ab79c2eaf2c76698c8f11b24d37.jpg)

    * 很多动态大小的数据结构，在创建时都有类似的内存布局：栈内存放的胖指针，指向堆内存分配出来的数据，之前介绍的 Rc 也是如此。

  * 完整的Rust类型的内存布局参见：https://cheats.rs/#data-layout

* **值的使用：**

  * 一个值如果没有实现 Copy，在赋值、传参以及函数返回时会被 Move

  * Copy 和 Move 在内部实现上，都是浅层的按位做内存复制，只不过 Copy 允许你访问之前的变量，而 Move 不允许。如下图所示：

    ![img](/images/4a0fd813e6722c9efef3c8be91b3d155.jpg)

  * 如果复制的只是原生类型（Copy）或者栈上的胖指针（Move），不涉及堆内存的复制也就是深拷贝（deep copy），那这个效率是非常高的，不必担心每次赋值或者每次传参带来的性能损失

* **值的销毁：**

  * 当所有者离开作用域，它拥有的值会被丢弃。从代码层面，Rust 到底是如何丢弃的呢？

  * 当一个值要被释放，它的 `Drop trait `会被调用。如下图所示：

    ![img](/images/0c0d83776e12a099453c837c997d93ae.jpg)

    变量 `greeting` 是一个字符串，在退出作用域时，其 `drop()` 函数被自动调用，释放堆上包含 “hello world” 的内存，然后再释放栈上的内存

  * 如果要释放的值是一个复杂的数据结构，比如一个结构体，那么这个结构体在调用 `drop() `时，会依次调用每一个字段的 `drop()` 函数，如果域又是一个复杂的结构或者集合类型，就会递归下去，直到每一个域都释放干净。如下图所示：

    ![img](/images/b80ec8eac77944512626bdfc3byy0094.jpg)

    `scores` 是 `HashMap`，它们本身需要额外 `drop()`。又因为 `HashMap` 的 `key` 是 `String`，所以还需要进一步调用这些 `key` 的 `drop()`。整个释放顺序从内到外是：先释放 `HashMap` 下的 `key`，然后释放 `HashMap` 堆上的表结构，最后释放栈上的内存。

* **堆内存释放：**

  * 所有权机制规定了，一个值只能有一个所有者，所以在释放堆内存的时候，整个过程简单清晰，就是单纯调用 Drop trait，不需要有其他顾虑。这种对值安全，也没有额外负担的释放能力，是 Rust 独有的。
  * 绝大多数情况下，不需要实现自己的 Drop trait，编译器缺省的行为就足够了。但是，如果你想自己控制 drop 行为，你也可以为这些数据结构实现它。
  * 如果自定义的 drop() 函数和系统的 drop() 函数都 drop() 某个域，Rust 编译器会确保，这个字段只会被 drop 一次。至于 Drop trait 怎么实现、有什么注意事项、什么场合下需要自定义，后续章节再细讲。

* **释放其他资源：**

  * 刚才讲 Rust 的 Drop trait 主要是为了应对堆内存释放的问题，其实，它还可以释放任何资源，比如 socket、文件、锁等等

  * 比如创建一个文件 file，往里面写入 “hello world”，当 file 离开作用域时，不但它的内存会被释放，它占用的资源、操作系统打开的文件描述符，也会被释放，也就是文件会自动被关闭

    ```rust
    use std::fs::File;
    use std::io::prelude::*;
    fn main() -> std::io::Result<()> {
        let mut file = File::create("foo.txt")?;
        file.write_all(b"hello world")?;
        Ok(())
    }
    ```

    

