---
title: "[Rust course]-01 基础入门-变量绑定与解构"
date: 2022-04-27T16:49:00+08:00
lastmod: 2022-04-27T16:49:00+08:00
author: nange
draft: false
description: "变量"

categories: ["rust"]
series: ["rust-course"]
series_weight: 1
tags: ["rust-notes"]
---

## 为何需要手动设置变量的可变性

在大多数语言中，变量一旦创建，要么可变要么不可变。
可变为编程提供了灵活性，不可变为编程提供了安全性，而Rust兼顾了这两者，既要灵活性又要安全性。
这是以Rust语言底层代码的复杂性为代价的，除了上面两个优点外，还有一个重要优点就是运行性能的提升，因为将本身不需要改变的变量声明为不可变在运行期会避免一些多于的runtime检查。

## 变量绑定

* `let a = "Hello World";` 这就完成了变量绑定

* 为何不叫赋值而叫绑定呢？
  
  * 这涉及Rust最核心的原则——**所有权**
  * 任何内存对象都是有主人的，而且一般情况下完全属于其主人
  * 绑定就是把对象绑定给一个变量，这个变量成为其主人（该对象之前的主人就会丧失对该对象的所有权）

## 变量可变性

* 变量默认是不可变的（更安全、高性能代码）

* 使用`mut`关键字让变量变为`可变的`，以实现更灵活的设计

* 这种规则让代码变得清晰，不会造成心智上的负担，给阅读带来了便利（是否会变一目了然）
  
## 变量解构

* `let`表达式不仅能用于变量绑定，还能进行复杂变量的解构：即从一个复杂变量中，匹配出该变量的一部分内容：
  
  ```rust
  fn main() {
      let (a, mut b) = (true, false);
      // a = true,不可变；b = false,可变
      println!("a = {:?}, b = {:?}", a, b);
  
      b = true;
      assert_eq!(a, b);
  }
  ```

## 变量和常量之间的差异

变量值不可变和很多语言都有的编程概念：`常量(constant)`很像。 但常量和变量之间存在一些差异：

* 常量不允许使用`mut`。常量不仅默认不可变，而且自始至终不可变。其在编译完成后就确定了它的值

* 常量使用`const`关键字而不是`let`来声明，并且必须标注类型

  *

   ```rust
    const MAX_POINTS: u32 = 100_000;
    ```

  * 常量的命名约定是全字母大写，并使用下划线分割，数字可插入下划线提高可读性

* 常量可在任意作用域内声明，包括全局作用域，在声明的作用域内，常量在程序运行的整个过程中都有效
* 这对于需要在多处代码共享一个不可变的值时非常有用
  
## 变量遮蔽(shadowing)

* Rust允许声明相同的变量名，后面声明的会遮蔽前面的
  
  ```rust
  fn main() {
      let x = 5;
      // 在main函数的作用域内对之前的x进行遮蔽
      let x = x + 1;
      {
          // 在当前的花括号作用域内，对之前的x进行遮蔽
          let x = x * 2;
          println!("The value of x in the inner scope is: {}", x);
      }
      println!("The value of x is: {}", x);
  }
  ```

* 这个`mut`变量的使用是不同的，第二个let生成了完全不同的新变量，涉及一次内存对象的再分配，而`mut`声明的变量，可以修改同一内存地址上的值，并不会发生内存分配，性能也更好
* 变量遮蔽的用处在于，如果在某个作用域不需要使用之前的变量，就可以使用相同的名字，不用绞尽脑汁想更多名字（go语言用户表示非常实用！）
